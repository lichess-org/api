/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/api/users/status": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get real-time users status
     * @description Read the `online`, `playing` and `streaming` flags of several users.
     *     This API is very fast and cheap on lichess side.
     *     So you can call it quite often (like once every 5 seconds).
     *     Use it to track players and know when they're connected on lichess and playing games.
     *
     */
    get: operations["apiUsersStatus"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/player": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all top 10
     * @description Get the top 10 players for each speed and variant.
     *     See <https://lichess.org/player>.
     *
     */
    get: operations["player"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/player/top/{nb}/{perfType}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get one leaderboard
     * @description Get the leaderboard for a single speed or variant (a.k.a. `perfType`).
     *     There is no leaderboard for correspondence or puzzles.
     *     See <https://lichess.org/player/top/200/bullet>.
     *
     */
    get: operations["playerTopNbPerfType"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/user/{username}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get user public data
     * @description Read public data of a user.
     *
     */
    get: operations["apiUser"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/user/{username}/rating-history": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get rating history of a user
     * @description Read rating history of a user, for all perf types.
     *     There is at most one entry per day.
     *     Format of an entry is `[year, month, day, rating]`.
     *     `month` starts at zero (January).
     *
     */
    get: operations["apiUserRatingHistory"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/user/{username}/perf/{perf}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get performance statistics of a user
     * @description Read performance statistics of a user, for a single performance.
     *     Similar to the [performance pages on the website](https://lichess.org/@/thibault/perf/bullet).
     *
     */
    get: operations["apiUserPerf"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/user/{username}/activity": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get user activity
     * @description Read data to generate the activity feed of a user.
     *
     */
    get: operations["apiUserActivity"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/puzzle/daily": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get the daily puzzle
     * @description Get the daily Lichess puzzle in JSON format.
     *     Alternatively, you can [post it in your slack workspace](https://lichess.org/daily-puzzle-slack).
     *
     */
    get: operations["apiPuzzleDaily"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/puzzle/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a puzzle by its ID
     * @description Get a single Lichess puzzle in JSON format.
     */
    get: operations["apiPuzzleId"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/puzzle/next": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a new puzzle
     * @description Get a random Lichess puzzle in JSON format.
     *
     *     If authenticated, only returns puzzles that the user has never seen before.
     *
     *     **DO NOT** use this endpoint to enumerate puzzles for mass download. Instead, download the [full public puzzle database](https://database.lichess.org/#puzzles).
     *
     */
    get: operations["apiPuzzleNext"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/puzzle/activity": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get your puzzle activity
     * @description Download your puzzle activity in [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
     *     Puzzle activity is sorted by reverse chronological order (most recent first)
     *     We recommend streaming the response, for it can be very long.
     *
     */
    get: operations["apiPuzzleActivity"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/puzzle/replay/{days}/{theme}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get puzzles to replay
     * @description Gets the puzzle IDs of remaining puzzles to re-attempt in JSON format.
     */
    get: operations["apiPuzzleReplay"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/puzzle/dashboard/{days}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get your puzzle dashboard
     * @description Download your [puzzle dashboard](https://lichess.org/training/dashboard/30/dashboard) as JSON.
     *     Also includes all puzzle themes played, with aggregated results.
     *     Allows re-creating the [improvement/strengths](https://lichess.org/training/dashboard/30/improvementAreas) interfaces.
     *
     */
    get: operations["apiPuzzleDashboard"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/storm/dashboard/{username}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get the storm dashboard of a player
     * @description Download the [storm dashboard](https://lichess.org/storm/dashboard/mrbasso) of any player as JSON.
     *     Contains the aggregated highscores, and the history of storm runs aggregated by days.
     *     Use `?days=0` if you only care about the highscores.
     *
     */
    get: operations["apiStormDashboard"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/racer": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create and join a puzzle race
     * @description Create a new private [puzzle race](https://lichess.org/racer).
     *     The Lichess user who creates the race must join the race page,
     *     and manually start the race when enough players have joined.
     *     - <https://lichess.org/racer>
     *
     */
    post: operations["racerPost"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/users": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get users by ID
     * @description Get up to 300 users by their IDs. Users are returned in the same order as the IDs.
     *     The method is `POST` to allow a longer list of IDs to be sent in the request body.
     *     Please do not try to download all the Lichess users with this endpoint, or any other endpoint.
     *     An API is not a way to fully export a website. We do not provide a full download of the Lichess users.
     *     This endpoint is limited to 8,000 users every 10 minutes, and 120,000 every day.
     *
     */
    post: operations["apiUsers"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/account": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get my profile
     * @description Public information about the logged in user.
     *
     */
    get: operations["accountMe"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/account/email": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get my email address
     * @description Read the email address of the logged in user.
     *
     */
    get: operations["accountEmail"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/account/preferences": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get my preferences
     * @description Read the preferences of the logged in user.
     *     - <https://lichess.org/account/preferences/game-display>
     *     - <https://github.com/ornicar/lila/blob/master/modules/pref/src/main/Pref.scala>
     *
     */
    get: operations["account"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/account/kid": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get my kid mode status
     * @description Read the kid mode status of the logged in user.
     *     - <https://lichess.org/account/kid>
     *
     */
    get: operations["accountKid"];
    put?: never;
    /**
     * Set my kid mode status
     * @description Set the kid mode status of the logged in user.
     *     - <https://lichess.org/account/kid>
     *
     */
    post: operations["accountKidPost"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/timeline": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get my timeline
     * @description Get the timeline events of the logged in user.
     *
     */
    get: operations["timeline"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/game/export/{gameId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export one game
     * @description Download one game in either PGN or JSON format.
     *     Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
     *
     */
    get: operations["gamePgn"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/user/{username}/current-game": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export ongoing game of a user
     * @description Download the ongoing game, or the last game played, of a user.
     *     Available in either PGN or JSON format.
     *     Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
     *
     */
    get: operations["apiUserCurrentGame"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/games/user/{username}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export games of a user
     * @description Download all games of any user in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
     *     Games are sorted by reverse chronological order (most recent first).
     *     We recommend streaming the response, for it can be very long.
     *     <https://lichess.org/@/german11> for instance has more than 500,000 games.
     *     The game stream is throttled, depending on who is making the request:
     *       - Anonymous request: 20 games per second
     *       - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
     *       - Authenticated, downloading your own games: 60 games per second
     *
     */
    get: operations["apiGamesUser"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/games/export/_ids": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Export games by IDs
     * @description Download games by IDs in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
     *     Games are sorted by reverse chronological order (most recent first)
     *     The method is `POST` so a longer list of IDs can be sent in the request body.
     *     300 IDs can be submitted.
     *     Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
     *
     */
    post: operations["gamesExportIds"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/stream/games-by-users": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Stream games of users
     * @description Stream the games played between a list of users, in real time.
     *     Only games where **both players** are part of the list are included.
     *     The stream emits an event each time a game is started or finished.
     *     To also get all current ongoing games at the beginning of the stream, use the `withCurrentGames` flag.
     *     Games are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *     Maximum number of users: 300.
     *     The method is `POST` so a longer list of IDs can be sent in the request body.
     *
     */
    post: operations["gamesByUsers"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/stream/games/{streamId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Stream games by IDs
     * @description Creates a stream of games from an arbitrary streamId, and a list of game IDs.
     *     The stream first outputs the games that already exists, then emits an event each time a game is started or finished.
     *     Games are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *     Maximum number of games: 500 for anonymous requests, or 1000 for [OAuth2 authenticated](#section/Introduction/Authentication) requests.
     *     While the stream is open, it is possible to [add new game IDs to watch](#operation/gamesByIdsAdd).
     *
     */
    post: operations["gamesByIds"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/stream/games/{streamId}/add": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Add game IDs to stream
     * @description Add new game IDs for [an existing stream](#operation/gamesByIds) to watch.
     *     The stream will immediately outputs the games that already exists, then emit an event each time a game is started or finished.
     *
     */
    post: operations["gamesByIdsAdd"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/account/playing": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get my ongoing games
     * @description Get the ongoing games of the current user.
     *     Real-time and correspondence games are included.
     *     The most urgent games are listed first.
     *
     */
    get: operations["apiAccountPlaying"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/stream/game/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Stream moves of a game
     * @description Stream positions and moves of any ongoing game, in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *     A description of the game is sent as a first message.
     *     Then a message is sent each time a move is played.
     *     Finally a description of the game is sent when it finishes, and the stream is closed.
     *     Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API.
     *     No more than 8 game streams can be opened at the same time from the same IP address.
     *
     */
    get: operations["streamGame"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/import": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Import one game
     * @description Import a game from PGN. See <https://lichess.org/paste>.
     *     Rate limiting: 200 games per hour for OAuth requests, 100 games per hour for anonymous requests.
     *     To broadcast ongoing games, consider [pushing to a broadcast instead](#operation/broadcastPush).
     *     To analyse a position or a line, just construct an analysis board URL:
     *     [https://lichess.org/analysis/pgn/e4_e5_Nf3_Nc6_Bc4_Bc5_Bxf7+](https://lichess.org/analysis/pgn/e4_e5_Nf3_Nc6_Bc4_Bc5_Bxf7+)
     *
     */
    post: operations["gameImport"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/games/export/imports": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export your imported games
     * @description Download all games imported by you. Games are exported in PGN format.
     */
    get: operations["apiImportedGamesUser"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/games/export/bookmarks": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export your bookmarked games
     * @description Download all games bookmarked by you, in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
     *     Games are sorted by reverse chronological order (most recent first).
     *     We recommend streaming the response, for it can be very long.
     *
     */
    get: operations["apiExportBookmarks"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/tv/channels": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get current TV games
     * @description Get basic info about the best games being played for each speed and variant,
     *     but also computer games and bot games.
     *     See [lichess.org/tv](https://lichess.org/tv).
     *
     */
    get: operations["tvChannels"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/tv/feed": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Stream current TV game
     * @description Stream positions and moves of the current [TV game](https://lichess.org/tv) in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *     Try it with `curl https://lichess.org/api/tv/feed`.
     *
     */
    get: operations["tvFeed"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/tv/{channel}/feed": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Stream current TV game of a TV channel
     * @description Stream positions and moves of a current [TV channel's game](https://lichess.org/tv/rapid) in [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *     Try it with `curl https://lichess.org/api/tv/rapid/feed`.
     *
     */
    get: operations["tvChannelFeed"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/tv/{channel}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get best ongoing games of a TV channel
     * @description Get a list of ongoing games for a given TV channel. Similar to [lichess.org/games](https://lichess.org/games).
     *     Available in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
     *
     */
    get: operations["tvChannelGames"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/tournament": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get current tournaments
     * @description Get recently active and finished tournaments.
     *     This API is used to display the [Lichess tournament schedule](https://lichess.org/tournament).
     *
     */
    get: operations["apiTournament"];
    put?: never;
    /**
     * Create a new Arena tournament
     * @description Create a public or private Arena tournament.
     *     This endpoint mirrors the form on <https://lichess.org/tournament/new>.
     *     You can create up to 12 public tournaments per day, or 24 private tournaments.
     *     A team battle can be created by specifying the `teamBattleByTeam` argument.
     *     Additional restrictions:
     *       - clockTime + clockIncrement > 0
     *       - 15s and 0+1 variant tournaments cannot be rated
     *       - Clock time in comparison to tournament length must be reasonable: 3 <= (minutes * 60) / (96 * clockTime + 48 * clockIncrement + 15) <= 150
     *
     */
    post: operations["apiTournamentPost"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/tournament/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    /**
     * Get info about an Arena tournament
     * @description Get detailed info about recently finished, current, or upcoming tournament's duels, player standings, and other info.
     *
     */
    get: operations["tournament"];
    put?: never;
    /**
     * Update an Arena tournament
     * @description Update an Arena tournament.
     *     Be mindful not to make important changes to ongoing tournaments.
     *     Can be used to update a team battle.
     *     Additional restrictions:
     *       - clockTime + clockIncrement > 0
     *       - 15s and 0+1 variant tournaments cannot be rated
     *       - Clock time in comparison to tournament length must be reasonable: 3 <= (minutes * 60) / (96 * clockTime + 48 * clockIncrement + 15) <= 150
     *
     */
    post: operations["apiTournamentUpdate"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/tournament/{id}/join": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Join an Arena tournament
     * @description Join an Arena tournament, possibly with a password and/or a team.
     *     Also unpauses if you had previously [paused](#operation/apiTournamentWithdraw) the tournament.
     *
     */
    post: operations["apiTournamentJoin"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/tournament/{id}/withdraw": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Pause or leave an Arena tournament
     * @description Leave a future Arena tournament, or take a break on an ongoing Arena tournament.
     *     It's possible to join again later. Points and streaks are preserved.
     *
     */
    post: operations["apiTournamentWithdraw"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/tournament/{id}/terminate": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Terminate an Arena tournament
     * @description Terminate an Arena tournament
     *
     */
    post: operations["apiTournamentTerminate"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/tournament/team-battle/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a team battle
     * @description Set the teams and number of leaders of a team battle.
     *     To update the other attributes of a team battle, use the [tournament update endpoint](#operation/apiTournamentUpdate).
     *
     */
    post: operations["apiTournamentTeamBattlePost"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/tournament/{id}/games": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export games of an Arena tournament
     * @description Download games of a tournament in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
     *     Games are sorted by reverse chronological order (most recent first).
     *     The game stream is throttled, depending on who is making the request:
     *       - Anonymous request: 20 games per second
     *       - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
     *
     */
    get: operations["gamesByTournament"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/tournament/{id}/results": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get results of an Arena tournament
     * @description Players of an Arena tournament, with their score and performance, sorted by rank (best first).
     *     **Players are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON)**, i.e. one JSON object per line.
     *     If called on an ongoing tournament, results can be inconsistent
     *     due to ranking changes while the players are being streamed.
     *     Use on finished tournaments for guaranteed consistency.
     *
     */
    get: operations["resultsByTournament"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/tournament/{id}/teams": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get team standing of a team battle
     * @description Teams of a team battle tournament, with top players, sorted by rank (best first).
     *
     */
    get: operations["teamsByTournament"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/user/{username}/tournament/created": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get tournaments created by a user
     * @description Get all tournaments created by a given user.
     *     Tournaments are sorted by reverse chronological order of start date (last starting first).
     *     Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *     The stream is throttled, depending on who is making the request:
     *       - Anonymous request: 20 tournaments per second
     *       - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 tournaments per second
     *       - Authenticated, downloading your own tournaments: 50 games per second
     *
     */
    get: operations["apiUserNameTournamentCreated"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/user/{username}/tournament/played": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get tournaments played by a user
     * @description Get all tournaments played by a given user.
     *     Tournaments are sorted by reverse chronological order of start date (last played first).
     *     Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *     The stream is throttled, depending on who is making the request:
     *       - Anonymous request: 20 tournaments per second
     *       - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 tournaments per second
     *       - Authenticated, downloading your own tournaments: 50 games per second
     *
     */
    get: operations["apiUserNameTournamentPlayed"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/swiss/new/{teamId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new Swiss tournament
     * @description Create a Swiss tournament for your team.
     *     This endpoint mirrors the Swiss tournament form from your team pagee.
     *     You can create up to 12 tournaments per day.
     *     Additional restrictions:
     *       - clock.limit + clock.increment > 0
     *       - 15s and 0+1 variant tournaments cannot be rated
     *
     */
    post: operations["apiSwissNew"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/swiss/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The Swiss tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    /**
     * Get info about a Swiss tournament
     * @description Get detailed info about a Swiss tournament.
     *
     */
    get: operations["swiss"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/swiss/{id}/edit": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a Swiss tournament
     * @description Update a Swiss tournament.
     *     Be mindful not to make important changes to ongoing tournaments.
     *     Additional restrictions:
     *       - clock.limit + clock.increment > 0
     *       - 15s and 0+1 variant tournaments cannot be rated
     *
     */
    post: operations["apiSwissUpdate"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/swiss/{id}/schedule-next-round": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Manually schedule the next round
     * @description Manually schedule the next round date and time of a Swiss tournament.
     *     This sets the `roundInterval` field to `99999999`, i.e. manual scheduling.
     *     All further rounds will need to be manually scheduled, unless the `roundInterval` field is changed back to automatic scheduling.
     *
     */
    post: operations["apiSwissScheduleNextRound"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/swiss/{id}/join": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Join a Swiss tournament
     * @description Join a Swiss tournament, possibly with a password.
     *
     */
    post: operations["apiSwissJoin"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/swiss/{id}/withdraw": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Pause or leave a swiss tournament
     * @description Leave a future Swiss tournament, or take a break on an ongoing Swiss tournament.
     *     It's possible to join again later. Points are preserved.
     *
     */
    post: operations["apiSwissWithdraw"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/swiss/{id}/terminate": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Terminate a Swiss tournament
     * @description Terminate a Swiss tournament
     *
     */
    post: operations["apiSwissTerminate"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/swiss/{id}.trf": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export TRF of a Swiss tournament
     * @description Download a tournament in the Tournament Report File format, the FIDE standard.
     *     Documentation: <https://www.fide.com/FIDE/handbook/C04Annex2_TRF16.pdf>
     *     Example: <https://lichess.org/swiss/j8rtJ5GL.trf>
     *
     */
    get: operations["swissTrf"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/swiss/{id}/games": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export games of a Swiss tournament
     * @description Download games of a swiss tournament in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format.
     *     Games are sorted by chronological order.
     *     The game stream is throttled, depending on who is making the request:
     *       - Anonymous request: 20 games per second
     *       - [OAuth2 authenticated](#section/Introduction/Authentication) request: 30 games per second
     *
     */
    get: operations["gamesBySwiss"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/swiss/{id}/results": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get results of a swiss tournament
     * @description Players of a swiss tournament, with their score and performance, sorted by rank (best first).
     *     Players are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *     If called on an ongoing tournament, results can be inconsistent
     *     due to ranking changes while the players are being streamed.
     *     Use on finished tournaments for guaranteed consistency.
     *
     */
    get: operations["resultsBySwiss"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/team/{teamId}/swiss": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get team swiss tournaments
     * @description Get all swiss tournaments of a team.
     *     Tournaments are sorted by reverse chronological order of start date (last starting first).
     *     Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *
     */
    get: operations["apiTeamSwiss"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/study/{studyId}/{chapterId}.pgn": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export one study chapter
     * @description Download one study chapter in PGN format.
     *
     */
    get: operations["studyChapterPgn"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/study/{studyId}.pgn": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export all chapters
     * @description Download all chapters of a study in PGN format.
     *
     */
    get: operations["studyAllChaptersPgn"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    /**
     * Study metadata
     * @description Only get the study headers, including `Last-Modified`.
     *
     */
    head: operations["studyAllChaptersHead"];
    patch?: never;
    trace?: never;
  };
  "/api/study/{studyId}/import-pgn": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Import PGN into a study
     * @description Imports arbitrary PGN into an existing [study](https://lichess.org/study). Creates a new chapter in the study.
     *     If the PGN contains multiple games (separated by 2 or more newlines)
     *     then multiple chapters will be created within the study.
     *     Note that a study can contain at most 64 chapters.
     *
     */
    post: operations["apiStudyImportPGN"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/study/by/{username}/export.pgn": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export all studies of a user
     * @description Download all chapters of all studies of a user in PGN format.
     *     If authenticated, then all public, unlisted, and private studies are included.
     *     If not, only public (non-unlisted) studies are included.
     *
     */
    get: operations["studyExportAllPgn"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/study/by/{username}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List studies of a user
     * @description Get metadata (name and dates) of all studies of a user.
     *     If authenticated, then all public, unlisted, and private studies are included.
     *     If not, only public (non-unlisted) studies are included.
     *     Studies are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *
     */
    get: operations["studyListMetadata"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/study/{studyId}/{chapterId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete a study chapter
     * @description Delete a chapter of a study you own. This is definitive.
     *     A study must have at least one chapter; so if you delete the last chapter,
     *     an empty one will be automatically created to replace it.
     *
     */
    delete: operations["apiStudyStudyIdChapterIdDelete"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/broadcast": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get official broadcasts
     * @description Get all incoming, ongoing, and finished official broadcasts.
     *     The broadcasts are sorted by start date, most recent first.
     *     Broadcasts are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *
     */
    get: operations["broadcastsOfficial"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/broadcast/top": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get paginated top broadcast previews
     * @description The same data, in the same order, as can be seen on [https://lichess.org/broadcast](/broadcast).
     *
     */
    get: operations["broadcastsTop"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/broadcast/by/{username}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get broadcasts created by a user
     * @description Get all incoming, ongoing, and finished official broadcasts.
     *     The broadcasts are sorted by created date, most recent first.
     *
     */
    get: operations["broadcastsByUser"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/broadcast/new": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a broadcast tournament
     * @description Create a new broadcast tournament to relay external games.
     *     This endpoint accepts the same form data as the [web form](https://lichess.org/broadcast/new).
     *
     */
    post: operations["broadcastTourCreate"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/broadcast/{broadcastTournamentId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a broadcast tournament
     * @description Get information about a broadcast tournament.
     *
     */
    get: operations["broadcastTourGet"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/broadcast/{broadcastTournamentId}/players": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get players of a broadcast
     * @description Get the list of players of a broadcast tournament, if available.
     *
     */
    get: operations["broadcastPlayersGet"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/broadcast/{broadcastTournamentId}/edit": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update your broadcast tournament
     * @description Update information about a broadcast tournament that you created.
     *     This endpoint accepts the same form data as the web form.
     *     All fields must be populated with data. Missing fields will override the broadcast with empty data.
     *
     */
    post: operations["broadcastTourUpdate"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/broadcast/{broadcastTournamentId}/new": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a broadcast round
     * @description Create a new broadcast round to relay external games.
     *     This endpoint accepts the same form data as the web form.
     *
     *     Choose one between `syncUrl`, `syncUrls`, `syncIds` and `syncUsers`, if it is missing, the broadcast needs to be fed by [pushing PGN to it](#operation/broadcastPush)
     *
     */
    post: operations["broadcastRoundCreate"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/broadcast/{broadcastTournamentSlug}/{broadcastRoundSlug}/{broadcastRoundId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a broadcast round
     * @description Get information about a broadcast round.
     *
     */
    get: operations["broadcastRoundGet"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/broadcast/round/{broadcastRoundId}/edit": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a broadcast round
     * @description Update information about a broadcast round.
     *     This endpoint accepts the same form data as the web form.
     *     All fields must be populated with data. Missing fields will override the broadcast with empty data.
     *     For instance, if you omit `startDate`, then any pre-existing start date will be removed.
     *
     */
    post: operations["broadcastRoundUpdate"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/broadcast/round/{broadcastRoundId}/reset": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Reset a broadcast round
     * @description Remove any games from the broadcast round and reset it to its initial state.
     *
     */
    post: operations["broadcastRoundReset"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/broadcast/round/{broadcastRoundId}/push": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Push PGN to a broadcast round
     * @description Update a broadcast with new PGN.
     *     Only for broadcasts without a source URL.
     *
     */
    post: operations["broadcastPush"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/stream/broadcast/round/{broadcastRoundId}.pgn": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Stream an ongoing broadcast tournament as PGN
     * @description This streaming endpoint first sends all games of a broadcast tournament in PGN format.
     *     Then, it waits for new moves to be played. As soon as it happens, the entire PGN of the game is sent to the stream.
     *     The stream will also send PGNs when games are added to the tournament.
     *     This is the best way to get updates about an ongoing tournament. Streaming means no polling,
     *     and no pollings means no latency, and minimum impact on the server.
     *
     */
    get: operations["broadcastStreamRoundPgn"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/broadcast/round/{broadcastRoundId}.pgn": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export one round as PGN
     * @description Download all games of a single round of a broadcast tournament in PGN format.
     *     You *could* poll this endpoint to get updates about a tournament, but it would be slow,
     *     and very inefficient.
     *     Instead, consider [streaming the tournament](#operation/broadcastStreamRoundPgn) to get
     *     a new PGN every time a game is updated, in real-time.
     *
     */
    get: operations["broadcastRoundPgn"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/broadcast/{broadcastTournamentId}.pgn": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export all rounds as PGN
     * @description Download all games of all rounds of a broadcast in PGN format.
     *     If a `study:read` [OAuth token](#tag/OAuth) is provided,
     *     the private rounds where the user is a contributor will be available.
     *     You may want to [download only the games of a single round](#operation/broadcastRoundPgn) instead.
     *
     */
    get: operations["broadcastAllRoundsPgn"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/broadcast/my-rounds": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get your broadcast rounds
     * @description Stream all broadcast rounds you are a member of.
     *     Also includes broadcasts rounds you did not create, but were invited to.
     *     Also includes broadcasts rounds where you're a non-writing member. See the `writeable` flag in the response.
     *     Rounds are ordered by rank, which is roughly chronological, most recent first, slightly pondered with popularity.
     *
     */
    get: operations["broadcastMyRoundsGet"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/fide/player/{playerId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a FIDE player
     * @description Get information about a FIDE player.
     *
     */
    get: operations["fidePlayerGet"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/fide/player": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Search FIDE players
     * @description List of FIDE players search results for a query.
     *
     */
    get: operations["fidePlayerSearch"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/simul": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get current simuls
     * @description Get recently created, started, finished, simuls.
     *     Created and finished simul lists are not exhaustives, only those with
     *     strong enough host will be listed, the same filter is used to display simuls on https://lichess.org/simul.
     *     When [authenticated with OAuth2](#section/Introduction/Authentication), the pending list will be populated with your created, but unstarted simuls.
     *
     */
    get: operations["apiSimul"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/team/{teamId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a single team
     * @description Public info about a team. Includes the list of publicly visible leaders.
     */
    get: operations["teamShow"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/team/all": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get popular teams
     * @description Paginator of the most popular teams.
     *
     */
    get: operations["teamAll"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/team/of/{username}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Teams of a player
     * @description All the teams a player is a member of.
     *
     */
    get: operations["teamOfUsername"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/team/search": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Search teams
     * @description Paginator of team search results for a keyword.
     *
     */
    get: operations["teamSearch"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/team/{teamId}/users": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get members of a team
     * @description Members are sorted by reverse chronological order of joining the team (most recent first).
     *     OAuth is only required if the list of members is private.
     *     Up to 5,000 users are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *
     */
    get: operations["teamIdUsers"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/team/{teamId}/arena": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get team Arena tournaments
     * @description Get all Arena tournaments relevant to a team.
     *     Tournaments are sorted by reverse chronological order of start date (last starting first).
     *     Tournaments are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *
     */
    get: operations["apiTeamArena"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/team/{teamId}/join": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Join a team
     * @description Join a team.
     *     If the team requires a password but the `password` field is incorrect,
     *     then the call fails with `403 Forbidden`.
     *     Similarly, if the team join policy requires a confirmation but the
     *     `message` parameter is not given, then the call fails with
     *     `403 Forbidden`.
     *
     */
    post: operations["teamIdJoin"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/team/{teamId}/quit": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Leave a team
     * @description Leave a team.
     *     - <https://lichess.org/team>
     *
     */
    post: operations["teamIdQuit"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/team/{teamId}/requests": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get join requests
     * @description Get pending join requests of your team
     */
    get: operations["teamRequests"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/team/{teamId}/request/{userId}/accept": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Accept join request
     * @description Accept someone's request to join your team
     */
    post: operations["teamRequestAccept"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/team/{teamId}/request/{userId}/decline": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Decline join request
     * @description Decline someone's request to join your team
     */
    post: operations["teamRequestDecline"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/team/{teamId}/kick/{userId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Kick a user from your team
     * @description Kick a member out of one of your teams.
     *     - <https://lichess.org/team>
     *
     */
    post: operations["teamIdKickUserId"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/team/{teamId}/pm-all": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Message all members
     * @description Send a private message to all members of a team.
     *     You must be a team leader with the "Messages" permission.
     *
     */
    post: operations["teamIdPmAll"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/streamer/live": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get live streamers
     * @description Get basic info about currently streaming users.
     *     This API is very fast and cheap on lichess side.
     *     So you can call it quite often (like once every 5 seconds).
     *
     */
    get: operations["streamerLive"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/crosstable/{user1}/{user2}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get crosstable
     * @description Get total number of games, and current score, of any two users.
     *     If the `matchup` flag is provided, and the users are currently playing, also gets the current match game number and scores.
     *
     */
    get: operations["apiCrosstable"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/player/autocomplete": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Autocomplete usernames
     * @description Provides autocompletion options for an incomplete username.
     *
     */
    get: operations["apiPlayerAutocomplete"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/user/{username}/note": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get notes for a user
     * @description Get the private notes that you have added for a user.
     *
     */
    get: operations["readNote"];
    put?: never;
    /**
     * Add a note for a user
     * @description Add a private note available only to you about this account.
     *
     */
    post: operations["writeNote"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/rel/following": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get users followed by the logged in user
     * @description Users are streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *
     */
    get: operations["apiUserFollowing"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/rel/follow/{username}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Follow a player
     * @description Follow a player, adding them to your list of Lichess friends.
     *
     */
    post: operations["followUser"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/rel/unfollow/{username}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Unfollow a player
     * @description Unfollow a player, removing them from your list of Lichess friends.
     *
     */
    post: operations["unfollowUser"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/rel/block/{username}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Block a player
     * @description Block a player, adding them to your list of blocked Lichess users.
     *
     */
    post: operations["blockUser"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/rel/unblock/{username}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Unblock a player
     * @description Unblock a player, removing them from your list of blocked Lichess users.
     *
     */
    post: operations["unblockUser"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/stream/event": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Stream incoming events
     * @description Stream the events reaching a lichess user in real time as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *
     *     An empty line is sent every 6 seconds for keep alive purposes.
     *
     *     Each non-empty line is a JSON object containing a `type` field. Possible values are:
     *     - `gameStart` Start of a game
     *     - `gameFinish` Completion of a game
     *     - `challenge` A player sends you a challenge or you challenge someone
     *     - `challengeCanceled` A player cancels their challenge to you
     *     - `challengeDeclined` The opponent declines your challenge
     *
     *     When the stream opens, all current challenges and games are sent.
     *
     */
    get: operations["apiStreamEvent"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/board/seek": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a seek
     * @description Create a public seek, to start a game with a random player.
     *
     *     ### Real-time seek
     *
     *     Specify the `time` and `increment` clock values.
     *     The response is streamed but doesn't contain any information.
     *
     *     **Keep the connection open to keep the seek active**.
     *
     *     If the client closes the connection, the seek is canceled. This way, if the client terminates, the user won't be paired in a game they wouldn't play.
     *     When the seek is accepted, or expires, the server closes the connection.
     *
     *     **Make sure to also have an [Event stream](#operation/apiStreamEvent) open**, to be notified when a game starts.
     *     We recommend opening the [Event stream](#operation/apiStreamEvent) first, then the seek stream. This way,
     *     you won't miss the game event if the seek is accepted immediately.
     *
     *     ### Correspondence seek
     *
     *     Specify the `days` per turn value.
     *     The response is not streamed, it immediately completes with the seek ID. The seek remains active on the server until it is joined by someone.
     *
     */
    post: operations["apiBoardSeek"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/board/game/stream/{gameId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Stream Board game state
     * @description Stream the state of a game being played with the Board API, as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *
     *     Use this endpoint to get updates about the game in real-time, with a single request.
     *
     *     Each line is a JSON object containing a `type` field. Possible values are:
     *       - `gameFull` Full game data. All values are immutable, except for the `state` field.
     *       - `gameState` Current state of the game. Immutable values not included. Sent when a move is played, a draw is offered, or when the game ends.
     *       - `chatLine` Chat message sent by a user in the `room` "player" or "spectator".
     *       - `opponentGone` Whether the opponent has left the game, and how long before you can claim a win or draw.
     *
     *     The first line is always of type `gameFull`.
     *
     *     The server closes the stream when the game ends, or if the game has already ended.
     *
     */
    get: operations["boardGameStream"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/board/game/{gameId}/move/{move}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Make a Board move
     * @description Make a move in a game being played with the Board API.
     *     The move can also contain a draw offer/agreement.
     *
     */
    post: operations["boardGameMove"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/board/game/{gameId}/chat": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    /**
     * Fetch the game chat
     * @description Get the messages posted in the game chat
     *
     */
    get: operations["boardGameChatGet"];
    put?: never;
    /**
     * Write in the chat
     * @description Post a message to the player or spectator chat, in a game being played with the Board API.
     *
     */
    post: operations["boardGameChatPost"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/board/game/{gameId}/abort": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Abort a game
     * @description Abort a game being played with the Board API.
     *
     */
    post: operations["boardGameAbort"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/board/game/{gameId}/resign": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Resign a game
     * @description Resign a game being played with the Board API.
     *
     */
    post: operations["boardGameResign"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/board/game/{gameId}/draw/{accept}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Handle draw offers
     * @description Create/accept/decline draw offers.
     *     - `yes`: Offer a draw, or accept the opponent's draw offer.
     *     - `no`: Decline a draw offer from the opponent.
     *
     */
    post: operations["boardGameDraw"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/board/game/{gameId}/takeback/{accept}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Handle takeback offers
     * @description Create/accept/decline takebacks.
     *     - `yes`: Propose a takeback, or accept the opponent's takeback offer.
     *     - `no`: Decline a takeback offer from the opponent.
     *
     */
    post: operations["boardGameTakeback"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/board/game/{gameId}/claim-victory": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Claim victory of a game
     * @description Claim victory when the opponent has left the game for a while.
     *
     */
    post: operations["boardGameClaimVictory"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/board/game/{gameId}/berserk": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Berserk a tournament game
     * @description Go berserk on an arena tournament game. Halves the clock time, grants an extra point upon winning.
     *     Only available in arena tournaments that allow berserk, and before each player has made a move.
     *
     */
    post: operations["boardGameBerserk"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/bot/online": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get online bots
     * @description Stream the [online bot users](https://lichess.org/player/bots), as [ndjson](#section/Introduction/Streaming-with-ND-JSON). Throttled to 50 bot users per second.
     */
    get: operations["apiBotOnline"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/bot/account/upgrade": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Upgrade to Bot account
     * @description Upgrade a lichess player account into a Bot account. Only Bot accounts can use the Bot API.
     *     The account **cannot have played any game** before becoming a Bot account. The upgrade is **irreversible**. The account will only be able to play as a Bot.
     *     To upgrade an account to Bot, use the [official lichess-bot client](https://github.com/lichess-bot-devs/lichess-bot), or follow these steps:
     *     - Create an [API access token](https://lichess.org/account/oauth/token/create?scopes[]=bot:play) with "Play bot moves" permission.
     *     - `curl -d '' https://lichess.org/api/bot/account/upgrade -H "Authorization: Bearer <yourTokenHere>"`
     *     To know if an account has already been upgraded, use the [Get my profile API](#operation/accountMe):
     *     the `title` field should be set to `BOT`.
     *
     */
    post: operations["botAccountUpgrade"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/bot/game/stream/{gameId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Stream Bot game state
     * @description Stream the state of a game being played with the Bot API, as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
     *     Use this endpoint to get updates about the game in real-time, with a single request.
     *     Each line is a JSON object containing a `type` field. Possible values are:
     *     - `gameFull` Full game data. All values are immutable, except for the `state` field.
     *     - `gameState` Current state of the game. Immutable values not included.
     *     - `chatLine` Chat message sent by a user (or the bot itself) in the `room` "player" or "spectator".
     *     - `opponentGone` Whether the opponent has left the game, and how long before you can claim a win or draw.
     *     The first line is always of type `gameFull`.
     *
     */
    get: operations["botGameStream"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/bot/game/{gameId}/move/{move}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Make a Bot move
     * @description Make a move in a game being played with the Bot API.
     *     The move can also contain a draw offer/agreement.
     *
     */
    post: operations["botGameMove"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/bot/game/{gameId}/chat": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Fetch the game chat
     * @description Get the messages posted in the game chat
     *
     */
    get: operations["botGameChatGet"];
    put?: never;
    /**
     * Write in the chat
     * @description Post a message to the player or spectator chat, in a game being played with the Bot API.
     *
     */
    post: operations["botGameChat"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/bot/game/{gameId}/abort": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Abort a game
     * @description Abort a game being played with the Bot API.
     *
     */
    post: operations["botGameAbort"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/bot/game/{gameId}/resign": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Resign a game
     * @description Resign a game being played with the Bot API.
     *
     */
    post: operations["botGameResign"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/bot/game/{gameId}/draw/{accept}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Handle draw offers
     * @description Create/accept/decline draw offers with the Bot API.
     *     - `yes`: Offer a draw, or accept the opponent's draw offer.
     *     - `no`: Decline a draw offer from the opponent.
     *
     */
    post: operations["botGameDraw"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/bot/game/{gameId}/takeback/{accept}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Handle takeback offers
     * @description Create/accept/decline takebacks with the Bot API.
     *     - `yes`: Propose a takeback, or accept the opponent's takeback offer.
     *     - `no`: Decline a takeback offer from the opponent.
     *
     */
    post: operations["botGameTakeback"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/bot/game/{gameId}/claim-victory": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Claim victory of a game
     * @description Claim victory when the opponent has left the game for a while.
     *
     */
    post: operations["botGameClaimVictory"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/challenge": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List your challenges
     * @description Get a list of challenges created by or targeted at you.
     *
     */
    get: operations["challengeList"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/challenge/{username}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a challenge
     * @description Challenge someone to play. The targeted player can choose to accept or decline.
     *     If the challenge is accepted, you will be notified on the [event stream](#operation/apiStreamEvent)
     *     that a new game has started. The game ID will be the same as the challenge ID.
     *     Challenges for realtime games (not correspondence) expire after 20s if not accepted.
     *     To prevent that, use the `keepAliveStream` flag described below.
     *
     */
    post: operations["challengeCreate"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/challenge/{challengeId}/show": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Show one challenge
     * @description Get details about a challenge, even if it has been recently accepted, canceled or declined.
     *
     */
    get: operations["challengeShow"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/challenge/{challengeId}/accept": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Accept a challenge
     * @description Accept an incoming challenge.
     *     You should receive a `gameStart` event on the [incoming events stream](#operation/apiStreamEvent).
     *
     */
    post: operations["challengeAccept"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/challenge/{challengeId}/decline": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Decline a challenge
     * @description Decline an incoming challenge.
     *
     */
    post: operations["challengeDecline"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/challenge/{challengeId}/cancel": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel a challenge
     * @description Cancel a challenge you sent, or aborts the game if the challenge was accepted, but the game was not yet played.
     *     Note that the ID of a game is the same as the ID of the challenge that created it.
     *     Works for user challenges and open challenges alike.
     *
     */
    post: operations["challengeCancel"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/challenge/ai": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Challenge the AI
     * @description Start a game with Lichess AI.
     *     You will be notified on the [event stream](#operation/apiStreamEvent) that a new game has started.
     *
     */
    post: operations["challengeAi"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/challenge/open": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Open-ended challenge
     * @description Create a challenge that any 2 players can join.
     *     Share the URL of the challenge. the first 2 players to click it will be paired for a game.
     *     The response body also contains `whiteUrl` and `blackUrl`.
     *     You can control which color each player gets by giving them these URLs,
     *     instead of the main challenge URL.
     *     Open challenges expire after 24h.
     *     If the challenge creation is [authenticated with OAuth2](#section/Introduction/Authentication),
     *     then you can use the [challenge cancel endpoint](#operation/challengeCancel) to cancel it.
     *     To directly pair 2 known players, use [this endpoint](#operation/bulkPairingList) instead.
     *
     */
    post: operations["challengeOpen"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/challenge/{gameId}/start-clocks": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Start clocks of a game
     * @description Start the clocks of a game immediately, even if a player has not yet made a move.
     *     Requires the OAuth tokens of both players with `challenge:write` scope.
     *     If the clocks have already started, the call will have no effect.
     *
     *     For AI games with only one player, omit the `token2` parameter.
     *
     */
    post: operations["challengeStartClocks"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/bulk-pairing": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * View your bulk pairings
     * @description Get a list of bulk pairings you created.
     *
     */
    get: operations["bulkPairingList"];
    put?: never;
    /**
     * Create a bulk pairing
     * @description Schedule many games at once, up to 24h in advance.
     *     OAuth tokens are required for all paired players, with the `challenge:write` scope.
     *     You can schedule up to 500 games every 10 minutes. [Contact us](mailto:contact@lichess.org) if you need higher limits.
     *     If games have a real-time clock, each player must have only one pairing.
     *     For correspondence games, players can have multiple pairings within the same bulk.
     *
     *     **The entire bulk is rejected if:**
     *       - a token is missing
     *       - a token is present more than once (except in correspondence)
     *       - a token lacks the `challenge:write` scope
     *       - a player account is closed
     *       - a player is paired more than once (except in correspondence)
     *       - a bulk is already scheduled to start at the same time with the same player
     *       - you have 20 scheduled bulks
     *       - you have 1000 scheduled games
     *
     *     Partial bulks are never created. Either it all fails, or it all succeeds.
     *     When it fails, it does so with an error message explaining the issue.
     *     Failed bulks are not counted in the rate limiting, they are free.
     *     Fix the issues, manually or programmatically, then retry to schedule the bulk.
     *     A successful bulk creation returns a JSON bulk document. Its ID can be used for further operations.
     *
     */
    post: operations["bulkPairingCreate"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/bulk-pairing/{id}/start-clocks": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Manually start clocks
     * @description Immediately start all clocks of the games of a bulk pairing.
     *     This overrides the `startClocksAt` value of an existing bulk pairing.
     *     If the games have not yet been created (`bulk.pairAt` is in the future), then this does nothing.
     *     If the clocks have already started (`bulk.startClocksAt` is in the past), then this does nothing.
     *
     */
    post: operations["bulkPairingStartClocks"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/bulk-pairing/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Show a bulk pairing
     * @description Get a single bulk pairing by its ID.
     *
     */
    get: operations["bulkPairingGet"];
    put?: never;
    post?: never;
    /**
     * Cancel a bulk pairing
     * @description Cancel and delete a bulk pairing that is scheduled in the future.
     *     If the games have already been created, then this does nothing.
     *     Canceling a bulk pairing does not refund the rate limit cost of that bulk pairing.
     *
     */
    delete: operations["bulkPairingDelete"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/bulk-pairing/{id}/games": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Export games of a bulk pairing
     * @description Download games of a bulk in PGN or [ndjson](#section/Introduction/Streaming-with-ND-JSON) format, depending on the request `Accept` header.
     *
     */
    get: operations["bulkPairingIdGamesGet"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/round/{gameId}/add-time/{seconds}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Add time to the opponent clock
     * @description Add seconds to the opponent's clock. Can be used to create games with time odds.
     *
     */
    post: operations["roundAddTime"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/token/admin-challenge": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Admin challenge tokens
     * @description **This endpoint can only be used by Lichess administrators. It will not work if you do not have the appropriate permissions.** Tournament organizers should instead use [OAuth](#tag/OAuth) to obtain `challenge:write` tokens from users in order to perform bulk pairing.*
     *     Create and obtain `challenge:write` tokens for multiple users.
     *     If a similar token already exists for a user, it is reused. This endpoint is idempotent.
     *
     */
    post: operations["adminChallengeTokens"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/inbox/{username}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Send a private message
     * @description Send a private message to another player.
     *
     */
    post: operations["inboxUsername"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/cloud-eval": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get cloud evaluation of a position.
     * @description Get the cached evaluation of a position, if available.
     *     Opening positions have more chances of being available. There are about 15 million positions in the database.
     *     Up to 5 variations may be available. Variants are supported.
     *     Use this endpoint to fetch a few positions here and there.
     *     If you want to download a lot of positions, [get the full list](https://database.lichess.org/#evals) from our exported database.
     *
     */
    get: operations["apiCloudEval"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/external-engine": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List external engines
     * @description Lists all external engines that have been registered for the user,
     *     and the credentials required to use them.
     *
     */
    get: operations["apiExternalEngineList"];
    put?: never;
    /**
     * Create external engine
     * @description Registers a new external engine for the user. It can then be selected
     *     and used on the analysis board.
     *     After registering, the provider should start waiting for analyis requests.
     *
     */
    post: operations["apiExternalEngineCreate"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/external-engine/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The external engine id.
         * @example eei_aTKImBJOnv6j
         */
        id: string;
      };
      cookie?: never;
    };
    /**
     * Get external engine
     * @description Get properties and credentials of an external engine.
     *
     */
    get: operations["apiExternalEngineGet"];
    /**
     * Update external engine
     * @description Updates the properties of an external engine.
     *
     */
    put: operations["apiExternalEnginePut"];
    post?: never;
    /**
     * Delete external engine
     * @description Unregisters an external engine.
     *
     */
    delete: operations["apiExternalEngineDelete"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/external-engine/{id}/analyse": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The external engine id.
         * @example eei_aTKImBJOnv6j
         */
        id: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Analyse with external engine
     * @description **Endpoint: `https://engine.lichess.ovh/api/external-engine/{id}/analyse`**
     *     Request analysis from an external engine.
     *     Response content is streamed as [newline delimited JSON](#section/Introduction/Streaming-with-ND-JSON).
     *     The properties are based on the [UCI specification](https://backscattering.de/chess/uci/#engine).
     *     Analysis stops when the client goes away, the requested limit
     *     is reached, or the provider goes away.
     *
     */
    post: operations["apiExternalEngineAnalyse"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/external-engine/work": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Acquire analysis request
     * @description **Endpoint: `https://engine.lichess.ovh/api/external-engine/work`**
     *     Wait for an analysis requests to any of the external engines that
     *     have been registered with the given `secret`.
     *     Uses long polling.
     *     After acquiring a request, the provider should immediately
     *     [start streaming the results](#tag/External-engine/operation/apiExternalEngineSubmit).
     *
     */
    post: operations["apiExternalEngineAcquire"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/external-engine/work/{id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Answer analysis request
     * @description **Endpoint: `https://engine.lichess.ovh/api/external-engine/work/{id}`**
     *     Submit a stream of analysis as [UCI output](https://backscattering.de/chess/uci/#engine-info).
     *     * The engine should always be in `UCI_Chess960` mode.
     *     * `UCI_AnalyseMode` enabled if available.
     *     * It produces `info` with at least:
     *       - `depth`
     *       - `multipv` (between 1 and 5)
     *       - `score`
     *       - `nodes`
     *       - `time`
     *       - `pv`
     *     The server may close the connection at any time, indicating that
     *     the requester has gone away and analysis should be stopped.
     *
     */
    post: operations["apiExternalEngineSubmit"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/oauth": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Request authorization code
     * @description OAuth2 authorization endpoint.
     *     Start the OAuth2 Authorization Code Flow with PKCE by securely
     *     generating two random strings unique to each authorization
     *     request:
     *
     *     * `code_verifier`
     *     * `state`
     *
     *     Store these in session storage. Make sure not to reveal `code_verifier`
     *     to eavesdroppers. Do not show it in URLs, do not abuse `state` to store
     *     it, do not send it over insecure connections. However it is fine if
     *     the user themselves can extract `code_verifier`, which will always be
     *     possible for fully client-side apps.
     *     Then send the user to this endpoint. They will be prompted to grant
     *     authorization and then be redirected back to the given `redirect_uri`.
     *     If the authorization failed, the following query string parameters will
     *     be appended to the redirection:
     *
     *     * `error`, in particular with value `access_denied` if the user
     *        cancelled authorization
     *     * `error_description` to aid debugging
     *     * `state`, exactly as passed in the `state` parameter
     *
     *     If the authorization succeeded, the following query string parameters
     *     will be appended to the redirection:
     *
     *     * `code`, containing a fresh short-lived authorization code
     *     * `state`, exactly as passed in the `state` parameter
     *
     *     Next, to defend against cross site request forgery, check that the
     *     returned `state` matches the `state` you originally generated.
     *
     *     Finally, continue by using the authorization code to
     *     [obtain an access token](#operation/apiToken).
     *
     */
    get: operations["oauth"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/token": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Obtain access token
     * @description OAuth2 token endpoint. Exchanges an authorization code for an access token.
     *
     */
    post: operations["apiToken"];
    /**
     * Revoke access token
     * @description Revokes the access token sent as Bearer for this request.
     */
    delete: operations["apiTokenDelete"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/api/token/test": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Test multiple OAuth tokens
     * @description For up to 1000 OAuth tokens,
     *     returns their associated user ID and scopes,
     *     or `null` if the token is invalid.
     *     The method is `POST` so a longer list of tokens can be sent in the request body.
     *
     */
    post: operations["tokenTest"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/masters": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Masters database
     * @description **Endpoint: <https://explorer.lichess.ovh/masters>**
     *
     *     Example: `curl https://explorer.lichess.ovh/masters?play=d2d4,d7d5,c2c4,c7c6,c4d5`
     *
     */
    get: operations["openingExplorerMaster"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/lichess": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Lichess games
     * @description **Endpoint: <https://explorer.lichess.ovh/lichess>**
     *
     *     Games sampled from all Lichess players.
     *
     *     Example: `curl https://explorer.lichess.ovh/lichess?variant=standard&speeds=blitz,rapid,classical&ratings=2200,2500&fen=rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR%20w%20KQkq%20-%200%201`
     *
     */
    get: operations["openingExplorerLichess"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/player": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Player games
     * @description **Endpoint: <https://explorer.lichess.ovh/player>**
     *
     *     Games of a Lichess player.
     *
     *     Responds with a stream of [newline delimited JSON](#section/Introduction/Streaming-with-ND-JSON). Will start indexing
     *     on demand, immediately respond with the current results, and stream
     *     more updates until indexing is complete. The stream is throttled
     *     and deduplicated. Empty lines may be sent to avoid timeouts.
     *
     *     Will index new games at most once per minute, and revisit previously
     *     ongoing games at most once every day.
     *
     *     Example: `curl https://explorer.lichess.ovh/player?player=revoof&color=white&play=d2d4,d7d5&recentGames=1`
     *
     */
    get: operations["openingExplorerPlayer"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/master/pgn/{gameId}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * OTB master game
     * @description **Endpoint: `https://explorer.lichess.ovh/masters/pgn/{gameId}`**
     *
     *     Example: `curl https://explorer.lichess.ovh/masters/pgn/aAbqI4ey`
     *
     */
    get: operations["openingExplorerMasterGame"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/standard": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Tablebase lookup
     * @description **Endpoint: <https://tablebase.lichess.ovh>**
     *     Example: `curl http://tablebase.lichess.ovh/standard?fen=4k3/6KP/8/8/8/8/7p/8_w_-_-_0_1`
     *
     */
    get: operations["tablebaseStandard"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/atomic": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Tablebase lookup for Atomic chess
     * @description **Endpoint: <https://tablebase.lichess.ovh>**
     *
     */
    get: operations["tablebaseAtomic"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/antichess": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Tablebase lookup for Antichess
     * @description **Endpoint: <https://tablebase.lichess.ovh>**
     *
     */
    get: operations["antichessAtomic"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description See [available flair list and images](https://github.com/lichess-org/lila/tree/master/public/flair) */
    Flair: string;
    PerfTop10: {
      id?: string;
      username?: string;
      title?: string;
      patron?: boolean;
      online?: boolean;
      perfs?: {
        [key: string]: {
          rating: number;
          progress: number;
        };
      };
    }[];
    Top10s: {
      bullet?: components["schemas"]["PerfTop10"];
      blitz?: components["schemas"]["PerfTop10"];
      rapid?: components["schemas"]["PerfTop10"];
      classical?: components["schemas"]["PerfTop10"];
      ultraBullet?: components["schemas"]["PerfTop10"];
      crazyhouse?: components["schemas"]["PerfTop10"];
      chess960?: components["schemas"]["PerfTop10"];
      kingOfTheHill?: components["schemas"]["PerfTop10"];
      threeCheck?: components["schemas"]["PerfTop10"];
      antichess?: components["schemas"]["PerfTop10"];
      atomic?: components["schemas"]["PerfTop10"];
      horde?: components["schemas"]["PerfTop10"];
      racingKings?: components["schemas"]["PerfTop10"];
    };
    /** @example {
     *       "users": [
     *         {
     *           "id": "bahadirozen",
     *           "username": "BahadirOzen",
     *           "perfs": {
     *             "bullet": {
     *               "rating": 3018,
     *               "progress": 18
     *             }
     *           },
     *           "online": true,
     *           "title": "FM"
     *         },
     *         {
     *           "id": "penguingim1",
     *           "username": "penguingim1",
     *           "perfs": {
     *             "bullet": {
     *               "rating": 2983,
     *               "progress": -36
     *             }
     *           },
     *           "title": "GM",
     *           "online": true,
     *           "patron": true
     *         },
     *         {
     *           "id": "night-king96",
     *           "username": "Night-King96",
     *           "perfs": {
     *             "bullet": {
     *               "rating": 2958,
     *               "progress": 35
     *             }
     *           },
     *           "title": "GM"
     *         }
     *       ]
     *     } */
    Leaderboard: unknown;
    Perf: {
      /** @example 2945 */
      games?: number;
      /** @example 1609 */
      rating?: number;
      /** @example 60 */
      rd?: number;
      /** @example -22 */
      prog?: number;
      /** @description only appears if a user's perf rating are [provisional](https://lichess.org/faq#provisional) */
      prov?: boolean;
    };
    PuzzleModePerf: {
      /** @example 44 */
      runs?: number;
      /** @example 61 */
      score?: number;
    };
    Perfs: {
      chess960?: components["schemas"]["Perf"];
      atomic?: components["schemas"]["Perf"];
      racingKings?: components["schemas"]["Perf"];
      ultraBullet?: components["schemas"]["Perf"];
      blitz?: components["schemas"]["Perf"];
      kingOfTheHill?: components["schemas"]["Perf"];
      threeCheck?: components["schemas"]["Perf"];
      antichess?: components["schemas"]["Perf"];
      crazyhouse?: components["schemas"]["Perf"];
      bullet?: components["schemas"]["Perf"];
      correspondence?: components["schemas"]["Perf"];
      horde?: components["schemas"]["Perf"];
      puzzle?: components["schemas"]["Perf"];
      classical?: components["schemas"]["Perf"];
      rapid?: components["schemas"]["Perf"];
      storm?: components["schemas"]["PuzzleModePerf"];
      racer?: components["schemas"]["PuzzleModePerf"];
      streak?: components["schemas"]["PuzzleModePerf"];
    };
    Profile: {
      /** @example EC */
      flag?: string;
      location?: string;
      /** @example Free bugs! */
      bio?: string;
      /** @example Thibault Duplessis */
      realName?: string;
      /**
       * @description only appears if a user has set them
       * @example 1500
       */
      fideRating?: number;
      /**
       * @description only appears if a user has set them
       * @example 1500
       */
      uscfRating?: number;
      /**
       * @description only appears if a user has set them
       * @example 1500
       */
      ecfRating?: number;
      /**
       * @description only appears if a user has set them
       * @example 1500
       */
      cfcRating?: number;
      /**
       * @description only appears if a user has set them
       * @example 1500
       */
      rcfRating?: number;
      /**
       * @description only appears if a user has set them
       * @example 1500
       */
      dsbRating?: number;
      /** @example github.com/ornicar
       *     mas.to/@thibault */
      links?: string;
    };
    PlayTime: {
      /** @example 3296897 */
      total?: number;
      /** @example 12134 */
      tv?: number;
    };
    /**
     * @description only appears if the user is a titled player or a bot user
     * @enum {string}
     */
    Title:
      | "GM"
      | "WGM"
      | "IM"
      | "WIM"
      | "FM"
      | "WFM"
      | "NM"
      | "CM"
      | "WCM"
      | "WNM"
      | "LM"
      | "BOT";
    User: {
      /** @example georges */
      id: string;
      /** @example Georges */
      username: string;
      perfs?: components["schemas"]["Perfs"];
      flair?: components["schemas"]["Flair"];
      /**
       * Format: int64
       * @example 1290415680000
       */
      createdAt?: number;
      /**
       * @description only appears if a user's account is closed
       * @example false
       */
      disabled?: boolean;
      /**
       * @description only appears if a user's account is marked for the violation of [Lichess TOS](https://lichess.org/terms-of-service)
       * @example false
       */
      tosViolation?: boolean;
      profile?: components["schemas"]["Profile"];
      /**
       * Format: int64
       * @example 1522636452014
       */
      seenAt?: number;
      /** @example true */
      patron?: boolean;
      /** @example true */
      verified?: boolean;
      playTime?: components["schemas"]["PlayTime"];
      title?: components["schemas"]["Title"];
    };
    Count: {
      /** @example 9265 */
      all?: number;
      /** @example 7157 */
      rated?: number;
      /** @example 531 */
      ai?: number;
      /** @example 340 */
      draw?: number;
      /** @example 331 */
      drawH?: number;
      /** @example 4480 */
      loss?: number;
      /** @example 4207 */
      lossH?: number;
      /** @example 4440 */
      win?: number;
      /** @example 4378 */
      winH?: number;
      /** @example 71 */
      bookmark?: number;
      /** @example 6 */
      playing?: number;
      /** @example 66 */
      import?: number;
      /** @example 0 */
      me?: number;
    };
    UserExtended: components["schemas"]["User"] & {
      /**
       * Format: uri
       * @example https://lichess.org/@/georges
       */
      url?: string;
      /**
       * Format: uri
       * @example https://lichess.org/yqfLYJ5E/black
       */
      playing?: string;
      count?: components["schemas"]["Count"];
      /** @example false */
      streaming?: boolean;
      streamer?: {
        twitch?: {
          /**
           * Format: uri
           * @example https://www.twitch.tv/lichessdotorg
           */
          channel?: string;
        };
        youTube?: {
          /**
           * Format: uri
           * @example https://www.youtube.com/c/LichessDotOrg
           */
          channel?: string;
        };
      };
      /**
       * @description only appears if the request is [authenticated with OAuth2](#section/Introduction/Authentication)
       * @example true
       */
      followable?: boolean;
      /**
       * @description only appears if the request is [authenticated with OAuth2](#section/Introduction/Authentication)
       * @example false
       */
      following?: boolean;
      /**
       * @description only appears if the request is [authenticated with OAuth2](#section/Introduction/Authentication)
       * @example false
       */
      blocking?: boolean;
    };
    /** @example [
     *       {
     *         "name": "Bullet",
     *         "points": [
     *           [
     *             2011,
     *             0,
     *             8,
     *             1472
     *           ],
     *           [
     *             2011,
     *             0,
     *             9,
     *             1332
     *           ],
     *           [
     *             2011,
     *             8,
     *             12,
     *             1314
     *           ]
     *         ]
     *       },
     *       {
     *         "name": "Blitz",
     *         "points": [
     *           [
     *             2011,
     *             7,
     *             29,
     *             1332
     *           ]
     *         ]
     *       }
     *     ] */
    RatingHistory: unknown;
    /** @enum {string} */
    PerfType:
      | "ultraBullet"
      | "bullet"
      | "blitz"
      | "rapid"
      | "classical"
      | "correspondence"
      | "chess960"
      | "crazyhouse"
      | "antichess"
      | "atomic"
      | "horde"
      | "kingOfTheHill"
      | "racingKings"
      | "threeCheck";
    /** @example {
     *       "user": {
     *         "name": "thibault"
     *       },
     *       "perf": {
     *         "glicko": {
     *           "rating": 1672.42,
     *           "deviation": 45.13,
     *           "provisional": false
     *         },
     *         "nb": 5692,
     *         "progress": -27
     *       },
     *       "rank": 98121,
     *       "percentile": 69.7,
     *       "stat": {
     *         "perfType": {
     *           "key": "bullet",
     *           "name": "Bullet"
     *         },
     *         "highest": {
     *           "int": 1902,
     *           "at": "2021-05-31T08:58:53.701Z",
     *           "gameId": "YEDqtwig"
     *         },
     *         "lowest": {
     *           "int": 1417,
     *           "at": "2016-06-28T13:54:39.656Z",
     *           "gameId": "rNM4J1GJ"
     *         },
     *         "id": "thibault/1",
     *         "bestWins": {
     *           "results": [
     *             {
     *               "opRating": 2238,
     *               "opId": {
     *                 "id": "hyperdragon84",
     *                 "name": "HyperDragon84"
     *               },
     *               "at": "2019-06-19T17:09:05.187Z",
     *               "gameId": "DGB53z9w"
     *             },
     *             {
     *               "opRating": 2089,
     *               "opId": {
     *                 "id": "osipov",
     *                 "name": "osipov"
     *               },
     *               "at": "2017-06-18T09:46:05.016Z",
     *               "gameId": "gurRhuMi"
     *             },
     *             {
     *               "opRating": 2071,
     *               "opId": {
     *                 "id": "spark50",
     *                 "name": "Spark50"
     *               },
     *               "at": "2020-07-04T08:36:12.948Z",
     *               "gameId": "a93Dk1mv"
     *             },
     *             {
     *               "opRating": 2045,
     *               "opId": {
     *                 "id": "yasha43",
     *                 "name": "Yasha43"
     *               },
     *               "at": "2021-05-17T14:01:41.098Z",
     *               "gameId": "j3jZnGTr"
     *             },
     *             {
     *               "opRating": 2034,
     *               "opId": {
     *                 "id": "midedu",
     *                 "name": "midedu"
     *               },
     *               "at": "2020-06-27T17:32:47.001Z",
     *               "gameId": "OiaMVLQ8"
     *             }
     *           ]
     *         },
     *         "worstLosses": {
     *           "results": [
     *             {
     *               "opRating": 1186,
     *               "opId": {
     *                 "id": "happy0",
     *                 "name": "Happy0"
     *               },
     *               "at": "2016-07-07T19:48:29.077Z",
     *               "gameId": "Q01bbiN4"
     *             },
     *             {
     *               "opRating": 1197,
     *               "opId": {
     *                 "id": "kazmankiller86",
     *                 "name": "KazmanKiller86"
     *               },
     *               "at": "2016-10-16T14:21:37.748Z",
     *               "gameId": "Aivqh9Sp"
     *             },
     *             {
     *               "opRating": 1201,
     *               "opId": {
     *                 "id": "artem555",
     *                 "name": "artem555"
     *               },
     *               "at": "2016-08-28T16:21:30.923Z",
     *               "gameId": "tiRAbhnX"
     *             },
     *             {
     *               "opRating": 1265,
     *               "opId": {
     *                 "id": "arcenuu",
     *                 "name": "Arcenuu"
     *               },
     *               "at": "2016-12-24T14:28:03.866Z",
     *               "gameId": "A68wUOoh"
     *             },
     *             {
     *               "opRating": 1283,
     *               "opId": {
     *                 "id": "amritalib76",
     *                 "name": "Amritalib76"
     *               },
     *               "at": "2018-06-26T09:55:39.354Z",
     *               "gameId": "sbNVikmo"
     *             }
     *           ]
     *         },
     *         "count": {
     *           "all": 5858,
     *           "rated": 5688,
     *           "win": 2789,
     *           "loss": 2806,
     *           "draw": 263,
     *           "tour": 654,
     *           "berserk": 1,
     *           "opAvg": 1671.44,
     *           "seconds": 784886,
     *           "disconnects": 0
     *         },
     *         "resultStreak": {
     *           "win": {
     *             "cur": {
     *               "v": 0
     *             },
     *             "max": {
     *               "v": 11,
     *               "from": {
     *                 "at": "2021-06-14T15:38:50.681Z",
     *                 "gameId": "wTX2IExo"
     *               },
     *               "to": {
     *                 "at": "2021-06-15T18:41:46.970Z",
     *                 "gameId": "1z4rrjgw"
     *               }
     *             }
     *           },
     *           "loss": {
     *             "cur": {
     *               "v": 3,
     *               "from": {
     *                 "at": "2021-06-29T17:53:23.642Z",
     *                 "gameId": "pfcnjgik"
     *               },
     *               "to": {
     *                 "at": "2021-06-29T18:04:48.358Z",
     *                 "gameId": "6sPaGL8T"
     *               }
     *             },
     *             "max": {
     *               "v": 14,
     *               "from": {
     *                 "at": "2018-06-11T14:43:39.296Z",
     *                 "gameId": "1fc9dqun"
     *               },
     *               "to": {
     *                 "at": "2018-06-11T15:10:30.908Z",
     *                 "gameId": "Nzy6UgwY"
     *               }
     *             }
     *           }
     *         },
     *         "userId": {
     *           "id": "thibault",
     *           "name": "thibault",
     *           "title": null
     *         },
     *         "playStreak": {
     *           "nb": {
     *             "cur": {
     *               "v": 0
     *             },
     *             "max": {
     *               "v": 118,
     *               "from": {
     *                 "at": "2018-06-11T10:32:21.248Z",
     *                 "gameId": "UAsNnJbN"
     *               },
     *               "to": {
     *                 "at": "2018-06-11T15:13:01.193Z",
     *                 "gameId": "T7fHRaFG"
     *               }
     *             }
     *           },
     *           "time": {
     *             "cur": {
     *               "v": 0
     *             },
     *             "max": {
     *               "v": 12683,
     *               "from": {
     *                 "at": "2018-06-12T14:11:14.021Z",
     *                 "gameId": "IrZCAW58"
     *               },
     *               "to": {
     *                 "at": "2018-06-12T18:02:57.010Z",
     *                 "gameId": "RNF1mQ68"
     *               }
     *             }
     *           },
     *           "lastDate": "2021-06-29T18:04:48.358Z"
     *         }
     *       }
     *     } */
    PerfStat: unknown;
    UserActivityScore: {
      win: number;
      loss: number;
      draw: number;
      rp: {
        before?: number;
        after?: number;
      };
    };
    /**
     * @default standard
     * @example standard
     * @enum {string}
     */
    VariantKey:
      | "standard"
      | "chess960"
      | "crazyhouse"
      | "antichess"
      | "atomic"
      | "horde"
      | "kingOfTheHill"
      | "racingKings"
      | "threeCheck"
      | "fromPosition";
    UserActivityCorrespondenceGame: {
      id: string;
      /** @enum {string} */
      color: "white" | "black";
      url: string;
      variant: components["schemas"]["VariantKey"];
      /** @constant */
      speed: "correspondence";
      /** @constant */
      perf: "correspondence";
      rated: boolean;
      opponent: {
        user: string;
        rating: number;
      };
    };
    UserActivityFollowList: {
      ids: string[];
      nb?: number;
    };
    UserActivity: {
      interval: {
        start: number;
        end: number;
      };
      games?: {
        chess960?: components["schemas"]["UserActivityScore"];
        atomic?: components["schemas"]["UserActivityScore"];
        racingKings?: components["schemas"]["UserActivityScore"];
        ultraBullet?: components["schemas"]["UserActivityScore"];
        blitz?: components["schemas"]["UserActivityScore"];
        kingOfTheHill?: components["schemas"]["UserActivityScore"];
        bullet?: components["schemas"]["UserActivityScore"];
        correspondence?: components["schemas"]["UserActivityScore"];
        horde?: components["schemas"]["UserActivityScore"];
        puzzle?: components["schemas"]["UserActivityScore"];
        classical?: components["schemas"]["UserActivityScore"];
        rapid?: components["schemas"]["UserActivityScore"];
      };
      puzzles?: {
        score?: components["schemas"]["UserActivityScore"];
      };
      storm?: {
        runs?: number;
        score?: number;
      };
      racer?: {
        runs?: number;
        score?: number;
      };
      streak?: {
        runs?: number;
        score?: number;
      };
      tournaments?: {
        nb?: number;
        best?: {
          tournament: {
            id: string;
            name: string;
          };
          nbGames: number;
          score: number;
          rank: number;
          rankPercent: number;
        }[];
      };
      practice?: {
        url: string;
        name: string;
        nbPositions: number;
      }[];
      simuls?: string[];
      correspondenceMoves?: {
        nb: number;
        games: components["schemas"]["UserActivityCorrespondenceGame"][];
      };
      correspondenceEnds?: {
        score: components["schemas"]["UserActivityScore"];
        games: components["schemas"]["UserActivityCorrespondenceGame"][];
      };
      follows?: {
        in?: components["schemas"]["UserActivityFollowList"];
        out?: components["schemas"]["UserActivityFollowList"];
      };
      studies?: Record<string, never>;
      teams?: {
        url: string;
        name: string;
      }[];
      posts?: {
        topicUrl: string;
        topicName: string;
        posts: {
          url: string;
          text: string;
        }[];
      }[];
      patron?: {
        months: number;
      };
      stream?: boolean;
    };
    /** @example {
     *       "game": {
     *         "clock": "3+0",
     *         "id": "AHGPPS44",
     *         "perf": {
     *           "key": "blitz",
     *           "name": "Blitz"
     *         },
     *         "pgn": "d4 d5 Bf4 Bf5 Nf3 e6 c4 Nf6 Nc3 Bd6 Bg3 Nbd7 e3 O-O c5 Bxg3 hxg3 h6 Bd3 Ne4 Qc2 Ndf6 Nd2 Nxc3 Bxf5 exf5 bxc3 Ne4 Nxe4 fxe4 Rb1 b6 Rh5 bxc5 Rb5 cxd4 cxd4 c6 Qxc6 Rc8 Qxd5 Qf6 Qxe4 Rc1+ Ke2 Qa6 Qd5 Rc2+ Kf3 g6 Rxh6 Qf6+ Ke4",
     *         "players": [
     *           {
     *             "color": "white",
     *             "flair": "travel-places.ambulance",
     *             "id": "ericrosen",
     *             "name": "EricRosen",
     *             "patron": true,
     *             "rating": 2642,
     *             "title": "IM"
     *           },
     *           {
     *             "color": "black",
     *             "id": "anton_volovikov",
     *             "name": "Anton_Volovikov",
     *             "rating": 2619,
     *             "title": "FM"
     *           }
     *         ],
     *         "rated": true
     *       },
     *       "puzzle": {
     *         "id": "PSjmf",
     *         "initialPly": 52,
     *         "plays": 566,
     *         "rating": 2705,
     *         "solution": [
     *           "g8g7",
     *           "d5e5",
     *           "f6e5"
     *         ],
     *         "themes": [
     *           "endgame",
     *           "master",
     *           "short",
     *           "masterVsMaster",
     *           "crushing"
     *         ]
     *       }
     *     } */
    PuzzleAndGame: {
      game: {
        clock: string;
        id: string;
        perf: {
          key: components["schemas"]["PerfType"];
          name: string;
        };
        pgn: string;
        players: {
          color: string;
          flair?: components["schemas"]["Flair"];
          id: string;
          name: string;
          patron?: boolean;
          rating: number;
          title?: components["schemas"]["Title"];
        }[];
        rated: boolean;
      };
      puzzle: {
        id: string;
        initialPly: number;
        plays: number;
        rating: number;
        solution: string[];
        themes: string[];
      };
    };
    /** @example {
     *       "date": 1717460624888,
     *       "puzzle": {
     *         "fen": "6k1/3rqpp1/5b1p/p1p1pP1Q/1pB4P/1P1R1PP1/P7/6K1 w - - 1 1",
     *         "id": "BlOLL",
     *         "lastMove": "c7d7",
     *         "plays": 14703,
     *         "rating": 2018,
     *         "solution": [
     *           "h5f7",
     *           "e7f7",
     *           "d3d7",
     *           "f7c4",
     *           "b3c4"
     *         ],
     *         "themes": [
     *           "endgame",
     *           "crushing",
     *           "long",
     *           "sacrifice",
     *           "pin"
     *         ]
     *       },
     *       "win": true
     *     } */
    PuzzleActivity: {
      date: number;
      puzzle: {
        fen: string;
        id: string;
        lastMove: string;
        plays: number;
        rating: number;
        solution: string[];
        themes: string[];
      };
      win: boolean;
    };
    /** @example {
     *       "replay": {
     *         "days": 30,
     *         "theme": "opening",
     *         "nb": 2,
     *         "remaining": [
     *           "M5KzH",
     *           "prIYT"
     *         ]
     *       },
     *       "angle": {
     *         "key": "opening",
     *         "name": "Opening",
     *         "desc": "A tactic during the first phase of the game."
     *       }
     *     } */
    PuzzleReplay: {
      replay: {
        days: number;
        theme: string;
        nb: number;
        remaining: string[];
      };
      angle: {
        key: string;
        name: string;
        desc: string;
      };
    };
    PuzzlePerformance: {
      firstWins: number;
      nb: number;
      performance: number;
      puzzleRatingAvg: number;
      replayWins: number;
    };
    /** @example {
     *       "days": 30,
     *       "global": {
     *         "firstWins": 1,
     *         "nb": 2,
     *         "performance": 2032,
     *         "puzzleRatingAvg": 2032,
     *         "replayWins": 0
     *       },
     *       "themes": {
     *         "defensiveMove": {
     *           "results": {
     *             "firstWins": 0,
     *             "nb": 1,
     *             "performance": 1547,
     *             "puzzleRatingAvg": 2047,
     *             "replayWins": 0
     *           },
     *           "theme": "Defensive move"
     *         },
     *         "endgame": {
     *           "results": {
     *             "firstWins": 1,
     *             "nb": 2,
     *             "performance": 2032,
     *             "puzzleRatingAvg": 2032,
     *             "replayWins": 0
     *           },
     *           "theme": "Endgame"
     *         },
     *         "pin": {
     *           "results": {
     *             "firstWins": 1,
     *             "nb": 1,
     *             "performance": 2518,
     *             "puzzleRatingAvg": 2018,
     *             "replayWins": 0
     *           },
     *           "theme": "Pin"
     *         },
     *         "sacrifice": {
     *           "results": {
     *             "firstWins": 1,
     *             "nb": 1,
     *             "performance": 2518,
     *             "puzzleRatingAvg": 2018,
     *             "replayWins": 0
     *           },
     *           "theme": "Sacrifice"
     *         }
     *       }
     *     } */
    PuzzleDashboard: {
      days: number;
      global: components["schemas"]["PuzzlePerformance"];
      themes: {
        [key: string]: {
          results: components["schemas"]["PuzzlePerformance"];
          theme: string;
        };
      };
    };
    /** @example {
     *       "days": [
     *         {
     *           "_id": "2024/6/4",
     *           "combo": 32,
     *           "errors": 5,
     *           "highest": 1590,
     *           "moves": 60,
     *           "runs": 1,
     *           "score": 24,
     *           "time": 174
     *         }
     *       ],
     *       "high": {
     *         "allTime": 24,
     *         "day": 24,
     *         "month": 24,
     *         "week": 24
     *       }
     *     } */
    PuzzleStormDashboard: {
      days: {
        _id: string;
        combo: number;
        errors: number;
        highest: number;
        moves: number;
        runs: number;
        score: number;
        time: number;
      }[];
      high: {
        allTime: number;
        day: number;
        month: number;
        week: number;
      };
    };
    /** @example {
     *       "id": "MT4hr",
     *       "url": "https://lichess.org/racer/MT4hr"
     *     } */
    PuzzleRacer: {
      id: string;
      /** Format: uri */
      url: string;
    };
    UserPreferences: {
      dark?: boolean;
      transp?: boolean;
      /** Format: uri */
      bgImg?: string;
      is3d?: boolean;
      /** @enum {string} */
      theme?:
        | "blue"
        | "blue2"
        | "blue3"
        | "blue-marble"
        | "canvas"
        | "wood"
        | "wood2"
        | "wood3"
        | "wood4"
        | "maple"
        | "maple2"
        | "brown"
        | "leather"
        | "green"
        | "marble"
        | "green-plastic"
        | "grey"
        | "metal"
        | "olive"
        | "newspaper"
        | "purple"
        | "purple-diag"
        | "pink"
        | "ic";
      /** @enum {string} */
      pieceSet?:
        | "cburnett"
        | "merida"
        | "alpha"
        | "pirouetti"
        | "chessnut"
        | "chess7"
        | "reillycraig"
        | "companion"
        | "riohacha"
        | "kosal"
        | "leipzig"
        | "fantasy"
        | "spatial"
        | "california"
        | "pixel"
        | "maestro"
        | "fresca"
        | "cardinal"
        | "gioco"
        | "tatiana"
        | "staunty"
        | "governor"
        | "dubrovny"
        | "icpieces"
        | "shapes"
        | "letter";
      /** @enum {string} */
      theme3d?:
        | "Black-White-Aluminium"
        | "Brushed-Aluminium"
        | "China-Blue"
        | "China-Green"
        | "China-Grey"
        | "China-Scarlet"
        | "Classic-Blue"
        | "Gold-Silver"
        | "Light-Wood"
        | "Power-Coated"
        | "Rosewood"
        | "Marble"
        | "Wax"
        | "Jade"
        | "Woodi";
      /** @enum {string} */
      pieceSet3d?:
        | "Basic"
        | "Wood"
        | "Metal"
        | "RedVBlue"
        | "ModernJade"
        | "ModernWood"
        | "Glass"
        | "Trimmed"
        | "Experimental"
        | "Staunton"
        | "CubesAndPi";
      /** @enum {string} */
      soundSet?:
        | "silent"
        | "standard"
        | "piano"
        | "nes"
        | "sfx"
        | "futuristic"
        | "robot"
        | "music"
        | "speech";
      blindfold?: number;
      autoQueen?: number;
      autoThreefold?: number;
      takeback?: number;
      moretime?: number;
      clockTenths?: number;
      clockBar?: boolean;
      clockSound?: boolean;
      premove?: boolean;
      animation?: number;
      pieceNotation?: number;
      captured?: boolean;
      follow?: boolean;
      highlight?: boolean;
      destination?: boolean;
      coords?: number;
      replay?: number;
      challenge?: number;
      message?: number;
      submitMove?: number;
      confirmResign?: number;
      insightShare?: number;
      keyboardMove?: number;
      voiceMove?: boolean;
      zen?: number;
      ratings?: number;
      moveEvent?: number;
      rookCastle?: number;
    };
    Ok: {
      ok?: boolean;
    };
    TimelineEntryFollow: {
      /** @enum {string} */
      type: "follow";
      date: number;
      data: {
        u1: string;
        u2: string;
      };
    };
    TimelineEntryTeamJoin: {
      /** @enum {string} */
      type: "team-join";
      date: number;
      data: {
        userId: string;
        teamId: string;
      };
    };
    TimelineEntryTeamCreate: {
      /** @enum {string} */
      type: "team-create";
      date: number;
      data: {
        userId: string;
        teamId: string;
      };
    };
    TimelineEntryForumPost: {
      /** @enum {string} */
      type: "forum-post";
      date: number;
      data: {
        userId: string;
        topicId: string;
        topicName: string;
        postId: string;
      };
    };
    TimelineEntryBlogPost: {
      /** @enum {string} */
      type: "blog-post";
      date: number;
      data: {
        id: string;
        slug: string;
        title: string;
      };
    };
    TimelineEntryUblogPost: {
      /** @enum {string} */
      type: "ublog-post";
      date: number;
      data: {
        userId: string;
        id: string;
        slug: string;
        title: string;
      };
    };
    TimelineEntryTourJoin: {
      /** @enum {string} */
      type: "tour-join";
      date: number;
      data: {
        userId: string;
        tourId: string;
        tourName: string;
      };
    };
    TimelineEntryGameEnd: {
      /** @enum {string} */
      type: "game-end";
      date: number;
      data: {
        fullId: string;
        opponent: string;
        win: boolean;
        perf: components["schemas"]["PerfType"];
      };
    };
    TimelineEntrySimul: {
      /** @enum {string} */
      type: "simul-create" | "simul-join";
      date: number;
      data: {
        userId: string;
        simulId: string;
        simulName: string;
      };
    };
    TimelineEntryStudyLike: {
      /** @enum {string} */
      type: "study-like";
      date: number;
      data: {
        userId: string;
        studyId: string;
        studyName: string;
      };
    };
    TimelineEntryPlanStart: {
      /** @enum {string} */
      type: "plan-start";
      date: number;
      data: {
        userId: string;
      };
    };
    TimelineEntryPlanRenew: {
      /** @enum {string} */
      type: "plan-renew";
      date: number;
      data: {
        userId: string;
        months: number;
      };
    };
    TimelineEntryUblogPostLike: {
      /** @enum {string} */
      type: "ublog-post-like";
      date: number;
      data: {
        userId: string;
        id: string;
        title: string;
      };
    };
    TimelineEntryStreamStart: {
      /** @enum {string} */
      type: "stream-start";
      date: number;
      data: {
        id: string;
        title?: string;
      };
    };
    /** @example {
     *       "entries": [
     *         {
     *           "type": "follow",
     *           "data": {
     *             "u1": "neio",
     *             "u2": "chess-network"
     *           },
     *           "date": 1644232201429
     *         },
     *         {
     *           "type": "team-join",
     *           "data": {
     *             "userId": "neio",
     *             "teamId": "coders"
     *           },
     *           "date": 1644232201429
     *         },
     *         {
     *           "type": "team-create",
     *           "data": {
     *             "userId": "neio",
     *             "teamId": "coders"
     *           },
     *           "date": 1644232201429
     *         },
     *         {
     *           "type": "forum-post",
     *           "data": {
     *             "userId": "neio",
     *             "topicId": "AAAAAAAN",
     *             "topicName": "World's Tallest LEGO Tower Completed in City Square",
     *             "postId": "AAAAAAAL"
     *           },
     *           "date": 1644232201429
     *         },
     *         {
     *           "type": "ublog-post",
     *           "data": {
     *             "userId": "neio",
     *             "id": "og5pkt1c",
     *             "slug": "gotta-go-fast",
     *             "title": "Gotta Go Fast"
     *           },
     *           "date": 1644232201429
     *         },
     *         {
     *           "type": "tour-join",
     *           "data": {
     *             "userId": "chess-network",
     *             "tourId": "Z24oxqgU",
     *             "tourName": "Daily Blitz Arena"
     *           },
     *           "date": 1644232201429
     *         },
     *         {
     *           "type": "game-end",
     *           "data": {
     *             "fullId": "iGkAXUdEfLZC",
     *             "perf": "correspondence",
     *             "opponent": "chess-network",
     *             "win": false
     *           },
     *           "date": 1644232201429
     *         },
     *         {
     *           "type": "simul-create",
     *           "data": {
     *             "userId": "neio",
     *             "simulId": "m3c0Wvu3",
     *             "simulName": "RCA 1st Jan simul"
     *           },
     *           "date": 1644232201429
     *         },
     *         {
     *           "type": "simul-join",
     *           "data": {
     *             "userId": "chess-network",
     *             "simulId": "m3c0Wvu3",
     *             "simulName": "RCA 1st Jan simul"
     *           },
     *           "date": 1644232201429
     *         },
     *         {
     *           "type": "study-like",
     *           "data": {
     *             "userId": "neio",
     *             "studyId": "ma5AvZ7o",
     *             "studyName": "Free wins | Danish Gambit"
     *           },
     *           "date": 1644232201429
     *         },
     *         {
     *           "type": "plan-start",
     *           "data": {
     *             "userId": "chess-network"
     *           },
     *           "date": 1644232201429
     *         },
     *         {
     *           "type": "plan-renew",
     *           "data": {
     *             "userId": "chess-network",
     *             "months": 64
     *           },
     *           "date": 1644232201429
     *         },
     *         {
     *           "type": "blog-post",
     *           "data": {
     *             "id": "ZUviXRIAACYAVtMm",
     *             "slug": "lichess-development-made-easy-with-gitpod",
     *             "title": "Lichess Development Made Easy With Gitpod"
     *           },
     *           "date": 1644232201429
     *         },
     *         {
     *           "type": "ublog-post-like",
     *           "data": {
     *             "userId": "neio",
     *             "id": "ZUviXRIAACYAVtMm",
     *             "title": "Lichess Development Made Easy With Gitpod"
     *           },
     *           "date": 1644232201429
     *         },
     *         {
     *           "type": "stream-start",
     *           "data": {
     *             "id": "chess-network",
     *             "title": "Streamers Battle December !team | lichess.org"
     *           },
     *           "date": 1644232201429
     *         }
     *       ],
     *       "users": {
     *         "neio": {
     *           "id": "neio",
     *           "name": "Neio",
     *           "title": "NM"
     *         },
     *         "chess-network": {
     *           "id": "chess-network",
     *           "name": "Chess-Network",
     *           "title": "NM",
     *           "patron": true
     *         }
     *       }
     *     } */
    Timeline: {
      entries: (
        | components["schemas"]["TimelineEntryFollow"]
        | components["schemas"]["TimelineEntryTeamJoin"]
        | components["schemas"]["TimelineEntryTeamCreate"]
        | components["schemas"]["TimelineEntryForumPost"]
        | components["schemas"]["TimelineEntryBlogPost"]
        | components["schemas"]["TimelineEntryUblogPost"]
        | components["schemas"]["TimelineEntryTourJoin"]
        | components["schemas"]["TimelineEntryGameEnd"]
        | components["schemas"]["TimelineEntrySimul"]
        | components["schemas"]["TimelineEntryStudyLike"]
        | components["schemas"]["TimelineEntryPlanStart"]
        | components["schemas"]["TimelineEntryPlanRenew"]
        | components["schemas"]["TimelineEntryUblogPostLike"]
        | components["schemas"]["TimelineEntryStreamStart"]
      )[];
      users: {
        [key: string]: {
          id: string;
          name: string;
          title?: components["schemas"]["Title"];
          flair?: components["schemas"]["Flair"];
          patron?: boolean;
        };
      };
    };
    /** @example [Event "Rated Blitz game"]
     *     [Site "https://lichess.org/fY44h4OY"]
     *     [Date "2018.03.29"]
     *     [Round "-"]
     *     [White "pveldman"]
     *     [Black "thibault"]
     *     [Result "1-0"]
     *     [UTCDate "2018.03.29"]
     *     [UTCTime "01:38:15"]
     *     [WhiteElo "1610"]
     *     [BlackElo "1601"]
     *     [WhiteRatingDiff "+10"]
     *     [BlackRatingDiff "-10"]
     *     [Variant "Standard"]
     *     [TimeControl "180+0"]
     *     [ECO "C62"]
     *     [Opening "Ruy Lopez: Steinitz Defense"]
     *     [Termination "Normal"]
     *
     *     1. e4 { [%clk 0:03:00] } e5 { [%clk 0:03:00] } 2. Nf3 { [%clk 0:02:59] } Nc6 { [%clk 0:02:58] } 3. Bb5 { [%clk 0:02:57] } d6 { [%clk 0:02:55] } 4. h3 { [%clk 0:02:54] } Nf6 { [%clk 0:02:52] } 5. Bxc6+ { [%clk 0:02:52] } bxc6 { [%clk 0:02:49] } 6. d3 { [%clk 0:02:51] } Be7 { [%clk 0:02:46] } 7. O-O { [%clk 0:02:47] } O-O { [%clk 0:02:45] } 8. b3 { [%clk 0:02:45] } d5 { [%clk 0:02:45] } 9. exd5 { [%clk 0:02:33] } cxd5 { [%clk 0:02:40] } 10. Nxe5 { [%clk 0:02:31] } Qd6 { [%clk 0:02:38] } 1-0
     *      */
    GamePgn: string;
    /** @enum {string} */
    Speed:
      | "ultraBullet"
      | "bullet"
      | "blitz"
      | "rapid"
      | "classical"
      | "correspondence";
    /**
     * @description Game status code. https://github.com/lichess-org/scalachess/blob/0a7d6f2c63b1ca06cd3c958ed3264e738af5c5f6/src/main/scala/Status.scala#L16-L28
     * @enum {string}
     */
    GameStatus:
      | "created"
      | "started"
      | "aborted"
      | "mate"
      | "resign"
      | "stalemate"
      | "timeout"
      | "draw"
      | "outoftime"
      | "cheat"
      | "noStart"
      | "unknownFinish"
      | "variantEnd";
    LightUser: {
      id: string;
      name: string;
      flair?: components["schemas"]["Flair"];
      title?: components["schemas"]["Title"];
      patron?: boolean;
    };
    GameUser: {
      user?: components["schemas"]["LightUser"];
      rating?: number;
      ratingDiff?: number;
      name?: string;
      provisional?: boolean;
      aiLevel?: number;
      analysis?: {
        inaccuracy: number;
        mistake: number;
        blunder: number;
        acpl: number;
        accuracy?: number;
      };
      team?: string;
    };
    GameMoveAnalysis: {
      /** @description Evaluation in centipawns */
      eval?: number;
      /** @description Number of moves until forced mate */
      mate?: number;
      /**
       * @description Best move in UCI notation (only if played move was inaccurate)
       * @example c2c3
       */
      best?: string;
      /**
       * @description Best variation in SAN notation (only if played move was inaccurate)
       * @example c3 Nc6 d4 Qb6 Be2 Nge7 Na3 cxd4 cxd4 Nf5
       */
      variation?: string;
      /** @description Judgment annotation (only if played move was inaccurate) */
      judgment?: {
        /** @enum {string} */
        name?: "Inaccuracy" | "Mistake" | "Blunder";
        /** @example Blunder. Nxg6 was best. */
        comment?: string;
      };
    };
    /** @example {
     *       "id": "q7ZvsdUF",
     *       "rated": true,
     *       "variant": "standard",
     *       "speed": "blitz",
     *       "perf": "blitz",
     *       "createdAt": 1514505150384,
     *       "lastMoveAt": 1514505592843,
     *       "status": "draw",
     *       "players": {
     *         "white": {
     *           "user": {
     *             "name": "Lance5500",
     *             "title": "LM",
     *             "patron": true,
     *             "id": "lance5500"
     *           },
     *           "rating": 2389,
     *           "ratingDiff": 4
     *         },
     *         "black": {
     *           "user": {
     *             "name": "TryingHard87",
     *             "id": "tryinghard87"
     *           },
     *           "rating": 2498,
     *           "ratingDiff": -4
     *         }
     *       },
     *       "opening": {
     *         "eco": "D31",
     *         "name": "Semi-Slav Defense: Marshall Gambit",
     *         "ply": 7
     *       },
     *       "moves": "d4 d5 c4 c6 Nc3 e6 e4 Nd7 exd5 cxd5 cxd5 exd5 Nxd5 Nb6 Bb5+ Bd7 Qe2+ Ne7 Nxb6 Qxb6 Bxd7+ Kxd7 Nf3 Qa6 Ne5+ Ke8 Qf3 f6 Nd3 Qc6 Qe2 Kf7 O-O Kg8 Bd2 Re8 Rac1 Nf5 Be3 Qe6 Rfe1 g6 b3 Bd6 Qd2 Kf7 Bf4 Qd7 Bxd6 Nxd6 Nc5 Rxe1+ Rxe1 Qc6 f3 Re8 Rxe8 Nxe8 Kf2 Nc7 Qb4 b6 Qc4+ Nd5 Nd3 Qe6 Nb4 Ne7 Qxe6+ Kxe6 Ke3 Kd6 g3 h6 Kd3 h5 Nc2 Kd5 a3 Nc6 Ne3+ Kd6 h4 Nd8 g4 Ne6 Ke4 Ng7 Nc4+ Ke6 d5+ Kd7 a4 g5 gxh5 Nxh5 hxg5 fxg5 Kf5 Nf4 Ne3 Nh3 Kg4 Ng1 Nc4 Kc7 Nd2 Kd6 Kxg5 Kxd5 f4 Nh3+ Kg4 Nf2+ Kf3 Nd3 Ke3 Nc5 Kf3 Ke6 Ke3 Kf5 Kd4 Ne6+ Kc4",
     *       "clock": {
     *         "initial": 300,
     *         "increment": 3,
     *         "totalTime": 420
     *       }
     *     } */
    GameJson: {
      id: string;
      rated: boolean;
      variant: components["schemas"]["VariantKey"];
      speed: components["schemas"]["Speed"];
      perf: string;
      /** Format: int64 */
      createdAt: number;
      /** Format: int64 */
      lastMoveAt: number;
      status: components["schemas"]["GameStatus"];
      players: {
        white: components["schemas"]["GameUser"];
        black: components["schemas"]["GameUser"];
      };
      initialFen?: string;
      /** @enum {string} */
      winner?: "white" | "black";
      opening?: {
        eco?: string;
        name?: string;
        ply?: number;
      };
      moves?: string;
      pgn?: string;
      daysPerTurn?: number;
      analysis?: components["schemas"]["GameMoveAnalysis"][];
      tournament?: string;
      swiss?: string;
      clock?: {
        initial: number;
        increment: number;
        totalTime: number;
      };
      clocks?: number[];
      division?: {
        /** @description Ply at which the middlegame begins */
        middle?: number;
        /** @description Ply at which the endgame begins */
        end?: number;
      };
    };
    /** @example [
     *       {
     *         "id": "A5fcMO3k",
     *         "rated": true,
     *         "variant": "standard",
     *         "speed": "bullet",
     *         "perf": "bullet",
     *         "createdAt": 1525789431889,
     *         "status": 20,
     *         "statusName": "started",
     *         "clock": {
     *           "initial": 60,
     *           "increment": 0,
     *           "totalTime": 60
     *         },
     *         "players": {
     *           "white": {
     *             "userId": "kastorcito",
     *             "rating": 2617
     *           },
     *           "black": {
     *             "userId": "er_or",
     *             "rating": 2288
     *           }
     *         }
     *       },
     *       {
     *         "id": "A5fcMO3k",
     *         "rated": true,
     *         "variant": "standard",
     *         "speed": "bullet",
     *         "perf": "bullet",
     *         "createdAt": 1525789431889,
     *         "status": 31,
     *         "statusName": "resign",
     *         "clock": {
     *           "initial": 60,
     *           "increment": 0,
     *           "totalTime": 60
     *         },
     *         "players": {
     *           "white": {
     *             "userId": "kastorcito",
     *             "rating": 2617
     *           },
     *           "black": {
     *             "userId": "er_or",
     *             "rating": 2288
     *           }
     *         },
     *         "winner": "white"
     *       }
     *     ] */
    GameStream: unknown;
    /** @enum {string} */
    GameSource:
      | "lobby"
      | "friend"
      | "ai"
      | "api"
      | "tournament"
      | "position"
      | "import"
      | "importlive"
      | "simul"
      | "relay"
      | "pool"
      | "swiss";
    Variant: {
      key?: components["schemas"]["VariantKey"];
      name?: string;
      short?: string;
    };
    /** @example [
     *       {
     *         "id": "LuGQwhBb",
     *         "variant": {
     *           "key": "standard",
     *           "name": "Standard",
     *           "short": "Std"
     *         },
     *         "speed": "blitz",
     *         "perf": "blitz",
     *         "rated": true,
     *         "initialFen": "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
     *         "fen": "rnbqkb1r/1p1ppppp/p6n/2p4Q/8/1P2P3/P1PP1PPP/RNB1KBNR w KQkq - 0 4",
     *         "player": "white",
     *         "turns": 6,
     *         "startedAtTurn": 0,
     *         "source": "pool",
     *         "status": {
     *           "id": 20,
     *           "name": "started"
     *         },
     *         "createdAt": 1620029815106,
     *         "lastMove": "c7c5",
     *         "players": {
     *           "white": {
     *             "user": {
     *               "name": "ARM-777777",
     *               "title": "GM",
     *               "id": "arm-777777"
     *             },
     *             "rating": 3120
     *           },
     *           "black": {
     *             "user": {
     *               "name": "Flash_Marafon",
     *               "id": "flash_marafon"
     *             },
     *             "rating": 3015
     *           }
     *         }
     *       },
     *       {
     *         "fen": "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w",
     *         "wc": 180,
     *         "bc": 180
     *       },
     *       {
     *         "fen": "rnbqkbnr/pppppppp/8/8/8/4P3/PPPP1PPP/RNBQKBNR b",
     *         "lm": "e2e3",
     *         "wc": 180,
     *         "bc": 180
     *       },
     *       {
     *         "fen": "rnbqkb1r/pppppppp/7n/8/8/4P3/PPPP1PPP/RNBQKBNR w",
     *         "lm": "g8h6",
     *         "wc": 180,
     *         "bc": 180
     *       },
     *       {
     *         "fen": "rnbqkb1r/pppppppp/7n/8/8/1P2P3/P1PP1PPP/RNBQKBNR b",
     *         "lm": "b2b3",
     *         "wc": 177,
     *         "bc": 180
     *       },
     *       {
     *         "fen": "rnbqkb1r/1ppppppp/p6n/8/8/1P2P3/P1PP1PPP/RNBQKBNR w",
     *         "lm": "a7a6",
     *         "wc": 177,
     *         "bc": 177
     *       }
     *     ] */
    MoveStream: unknown;
    TvGame: {
      user: components["schemas"]["LightUser"] & {
        flair?: components["schemas"]["Flair"];
      };
      rating: number;
      gameId: string;
      /** @enum {string} */
      color: "white" | "black";
    };
    TvFeed: {
      /**
       * @description The type of message.
       *     A summary of the game is sent as the first message and when the featured game changes.
       *     Subsequent messages are just the FEN, last move, and clocks.
       *
       * @enum {string}
       */
      t: "featured" | "fen";
      /** @description The data of the message */
      d:
        | {
            /** @description The game ID */
            id: string;
            /** @enum {string} */
            orientation: "white" | "black";
            players: {
              /** @enum {string} */
              color: "white" | "black";
              user: {
                name: string;
                id: string;
                title?: string;
              };
              rating: number;
              /** @description The player's remaining time in seconds */
              seconds: number;
            }[];
            /** @description The FEN of the current position */
            fen: string;
          }
        | {
            /** @description The FEN of the current position */
            fen: string;
            /** @description The last move in UCI format */
            lm: string;
            /** @description White's clock in seconds */
            wc: number;
            /** @description Black's clock in seconds */
            bc: number;
          };
    };
    Clock: {
      limit?: number;
      increment?: number;
    };
    /**
     * @description 10: created, 20: started, 30: finished
     *
     * @example 30
     * @enum {integer}
     */
    ArenaStatus: 10 | 20 | 30;
    ArenaPerf: {
      /** @example blitz */
      key?: string;
      /** @example Blitz */
      name?: string;
      /** @example 1 */
      position?: number;
      /** @example ) */
      icon?: string;
    };
    ArenaRatingObj: {
      perf?: components["schemas"]["PerfType"];
      /** @example 1700 */
      rating?: number;
    };
    ArenaPosition:
      | {
          /** @example C41 */
          eco?: string;
          /** @example Philidor Defense */
          name?: string;
          /** @example rnbqkbnr/ppp2ppp/3p4/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - */
          fen?: string;
          /**
           * Format: uri
           * @example https://lichess.org/opening/Philidor_Defense
           */
          url?: string;
        }
      | {
          /** @constant */
          name?: "Custom position";
          /** @example rnbq1bnr/ppppkppp/8/4p3/4P3/8/PPPPKPPP/RNBQ1BNR w - - 2 3 */
          fen?: string;
        };
    /** @example {
     *       "id": "XhfVxYPG",
     *       "createdBy": "lichess",
     *       "system": "arena",
     *       "minutes": 27,
     *       "clock": {
     *         "limit": 60,
     *         "increment": 0
     *       },
     *       "rated": true,
     *       "fullName": "Hourly Bullet Arena",
     *       "nbPlayers": 4,
     *       "variant": {
     *         "key": "standard",
     *         "short": "Std",
     *         "name": "Standard"
     *       },
     *       "startsAt": 1716930043067,
     *       "finishesAt": 1716931663067,
     *       "status": 10,
     *       "perf": {
     *         "key": "bullet",
     *         "name": "Bullet",
     *         "position": 0,
     *         "icon": "T"
     *       },
     *       "secondsToStart": 871,
     *       "minRatedGames": {
     *         "nb": 20
     *       },
     *       "schedule": {
     *         "freq": "hourly",
     *         "speed": "bullet"
     *       }
     *     } */
    ArenaTournament: {
      id?: string;
      createdBy?: string;
      /** @constant */
      system?: "arena";
      minutes?: number;
      clock?: components["schemas"]["Clock"];
      rated?: boolean;
      fullName?: string;
      nbPlayers?: number;
      variant?: components["schemas"]["Variant"];
      /** Format: int64 */
      startsAt?: number;
      /** Format: int64 */
      finishesAt?: number;
      status?: components["schemas"]["ArenaStatus"];
      perf?: components["schemas"]["ArenaPerf"];
      secondsToStart?: number;
      hasMaxRating?: boolean;
      maxRating?: components["schemas"]["ArenaRatingObj"];
      minRating?: components["schemas"]["ArenaRatingObj"];
      minRatedGames?: {
        nb?: number;
      };
      botsAllowed?: boolean;
      minAccountAgeInDays?: number;
      onlyTitled?: boolean;
      teamMember?: string;
      private?: boolean;
      position?: components["schemas"]["ArenaPosition"];
      schedule?: {
        freq?: string;
        speed?: string;
      };
      teamBattle?: {
        teams?: string[];
        nbLeaders?: number;
      };
      winner?: {
        id?: string;
        name?: string;
        title?: components["schemas"]["Title"];
      };
    };
    ArenaTournaments: {
      created?: components["schemas"]["ArenaTournament"][];
      started?: components["schemas"]["ArenaTournament"][];
      finished?: components["schemas"]["ArenaTournament"][];
    };
    /**
     * @description Custom initial position (in FEN). Variant must be standard, fromPosition, or chess960 (if a valid 960 starting position), and the game cannot be rated.
     * @default rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
     */
    FromPositionFEN: string;
    Verdicts: {
      accepted: boolean;
      list: {
        condition: string;
        verdict: string;
      }[];
    };
    ArenaSheet: {
      scores: string;
      fire?: boolean;
    };
    ArenaTournamentFull: {
      id: string;
      fullName: string;
      rated?: boolean;
      spotlight?: {
        headline?: string;
      };
      berserkable?: boolean;
      onlyTitled?: boolean;
      clock: {
        increment: number;
        limit: number;
      };
      minutes?: number;
      createdBy?: string;
      system?: string;
      secondsToStart?: number;
      secondsToFinish?: number;
      isFinished: boolean;
      isRecentlyFinished?: boolean;
      pairingsClosed?: boolean;
      /** Format: int64 */
      startsAt?: string;
      nbPlayers: number;
      verdicts?: components["schemas"]["Verdicts"];
      /** @description The quote displayed on the tournament page */
      quote?: {
        text?: string;
        author?: string;
      };
      /** @description List of usernames allowed to join the tournament */
      allowList?: string[];
      hasMaxRating?: boolean;
      maxRating?: components["schemas"]["ArenaRatingObj"];
      minRating?: components["schemas"]["ArenaRatingObj"];
      minRatedGames?: {
        nb?: number;
      };
      botsAllowed?: boolean;
      minAccountAgeInDays?: number;
      perf?: {
        icon: string;
        key: string;
        name: string;
      };
      schedule?: {
        freq: string;
        speed: string;
      };
      description?: string;
      variant?: string;
      duels?: {
        id?: string;
        p?: {
          n?: string;
          r?: number;
          k?: number;
        }[];
      }[];
      standing?: {
        page?: number;
        players?: {
          name?: string;
          title?: components["schemas"]["Title"];
          patron?: boolean;
          flair?: components["schemas"]["Flair"];
          rank?: number;
          rating?: number;
          score?: number;
          sheet?: components["schemas"]["ArenaSheet"];
        }[];
      };
      featured?: {
        id?: string;
        fen?: string;
        orientation?: string;
        color?: string;
        lastMove?: string;
        white?: {
          name?: string;
          id?: string;
          rank?: number;
          rating?: number;
        };
        black?: {
          name?: string;
          id?: string;
          rank?: number;
          rating?: number;
        };
        c?: {
          /** @description white's clock in seconds */
          white?: number;
          /** @description black's clock in seconds */
          black?: number;
        };
      };
      podium?: {
        name?: string;
        title?: components["schemas"]["Title"];
        patron?: boolean;
        flair?: components["schemas"]["Flair"];
        rank?: number;
        rating?: number;
        score?: number;
        nb?: {
          game?: number;
          berserk?: number;
          win?: number;
        };
        performance?: number;
      }[];
      stats: {
        games: number;
        moves: number;
        whiteWins: number;
        blackWins: number;
        draws: number;
        berserks: number;
        averageRating: number;
      };
    };
    /** @example {
     *       "error": "This request is invalid because [...]"
     *     } */
    Error: {
      /** @description The cause of the error. */
      error?: string;
    };
    ArenaTournamentPlayed: {
      tournament?: components["schemas"]["ArenaTournament"];
      /** @example {
       *       "games": 10,
       *       "score": 14,
       *       "rank": 30,
       *       "performance": 1935
       *     } */
      player?: {
        games: number;
        score: number;
        rank: number;
        performance?: number;
      };
    };
    /**
     * @description Custom initial position (in FEN). Variant must be standard and the game cannot be rated.
     * @default rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
     */
    SwissFromPositionFEN: string;
    /**
     * @description The current state of the swiss tournament
     * @example created
     * @enum {string}
     */
    SwissStatus: "created" | "started" | "finished";
    SwissTournament: {
      id: string;
      createdBy: string;
      startsAt: string;
      name: string;
      clock: {
        limit: number;
        increment: number;
      };
      variant: string;
      round: number;
      nbRounds: number;
      nbPlayers: number;
      nbOngoing: number;
      status: components["schemas"]["SwissStatus"];
      stats?: {
        games: number;
        whiteWins: number;
        blackWins: number;
        draws: number;
        byes: number;
        absences: number;
        averageRating: number;
      };
      rated: boolean;
      verdicts: components["schemas"]["Verdicts"];
      nextRound?: {
        /** Format: date-time */
        at?: string;
        /** @description The number of seconds until the next round starts. */
        in?: number;
      };
    };
    /** @example {
     *       "error": "This user cannot edit this swiss"
     *     } */
    SwissUnauthorisedEdit: {
      error?: string;
    };
    /** @example [Event "All about the Sicilian Defense: Dragon Variation"]
     *     [Site "https://lichess.org/study/8c8bmUfy/qwnXMwVC"]
     *     [Result "*"]
     *     [UTCDate "2017.06.25"]
     *     [UTCTime "10:12:04"]
     *     [Variant "Standard"]
     *     [ECO "B76"]
     *     [Opening "Sicilian Defense: Dragon Variation, Yugoslav Attack, Panov Variation"]
     *     [Annotator "https://lichess.org/@/Francesco_Super"]
     *
     *     { This chapter will go over the Dragon Variation, a very common variation used by Black and it is the most aggressive variation in the Sicilian defense. }
     *     1. e4 c5 2. Nf3 { Simple developing move to control the d4 square } { [%csl Gd4,Gc5][%cal Gf3d4,Gc5d4] } 2... d6 { [%cal Gd6e5] } (2... e6 3. d4 cxd4 4. Nxd4 Nf6 5. e5 (5. Nc3 { [%cal Ge4e5] }) 5... Qa5+) 3. d4 { Whites want the exchange of pawns } { [%cal Gc5d4] } 3... cxd4 { [%cal Gf3d4] } 4. Nxd4 { Whites are now ahead in development but blacks still have the two central pawns whereas whites only one. } { [%csl Ge7,Gd6,Ge4] } 4... Nf6 { Blacks are now developing their knight and threatening the e4 pawn } { [%csl Ge4][%cal Gf6e4] } 5. Nc3 { The e4 pawn is now protected by the c3 knight } { [%csl Ge4,Bc3][%cal Rf6e4,Bc3e4] } 5... g6 { This is the DRAGON VARIATION. g6 allows the dark-squared bishop to develop and move to g7, controlling the long dark-squared diagonal } { [%csl Gd4] } 6. Be3 { [%cal Gd1d2,Gf2f3,Ge1c1,Gg2g4,Gh2h4,Gg4g5] } (6. Be2 Bg7 7. O-O Nc6 8. Be3 { [%cal Ge3d4] } (8. f3 Nxe4 { [%cal Gg7d4,Gc6d4] } 9. Nxc6 Qb6+ { [%cal Gb6c6,Gb6g1] } 10. Kh1 Nxc3 { [%cal Gc3d1,Gc3e2] } 11. bxc3 bxc6 { [%cal Gc8a6] }) 8... O-O 9. Nb3 a6 { [%cal Gb7b5,Gb5b4,Ge2c4] }) 6... Bg7 (6... Ng4 { [%cal Gg4e3] } 7. Bb5+ { [%cal Gb5e8,Gb8d7,Gc8d7,Gd1g4] } 7... Nc6 8. Nxc6 bxc6 9. Bxc6+ { [%cal Gc6a8] }) 7. f3 { The key opening moves for White, who attempt to castle queenside , whereas f3 strengthens the pawn structure, connecting e4 to the h2 and g2, while White also plan pushing to g4 and possibly h4. } { [%csl Bf3,Be3][%cal Rg2g4,Rh2h4,Rg4g5] } 7... O-O (7... h5 { Is operating against g4. }) 8. Qd2 { [%csl Gh6,Gg7][%cal Ge1c1,Ga1d1,Re3h6,Rd2h6] } 8... Nc6 { [%csl Gc6,Gh6][%cal Gb8c6,Ge1c1,Ga7a6,Ge3h6] } 9. g4 (9. Bh6 { [%cal Ge3d4] } 9... Bxh6 10. Qxh6 Nxd4) 9... Be6 10. Nxe6 fxe6 { [%cal Gf8f1] } 11. O-O-O Ne5 12. Be2 { [%csl Gf3][%cal Re5f3,Bd1h1,Bg1d1] } 12... Qc7 { [%csl Gc4][%cal Ge5c4,Gc4e3,Gc4d2,Bf8c8,Yc7c3] } 13. h4 Nc4 *
     *      */
    StudyPgn: unknown;
    /** @example {
     *       "chapters": [
     *         {
     *           "id": "iBjmYBya",
     *           "name": "test 2",
     *           "players": [
     *             {
     *               "name": "Carlsen, Magnus",
     *               "rating": 2837
     *             },
     *             {
     *               "name": "Chadaev, Nikolay",
     *               "rating": 2580
     *             }
     *           ],
     *           "status": "1-0"
     *         }
     *       ]
     *     } */
    StudyImportPgnChapters: {
      chapters?: {
        /** @description The chapter ID */
        id?: string;
        /** @description The chapter name */
        name?: string;
        players?: {
          /** @description The player name */
          name?: string | null;
          /** @description The player rating */
          rating?: number;
        }[];
        /** @description The chapter status */
        status?: string;
      }[];
    };
    /** @example {
     *       "id": "WTvnkWAL",
     *       "name": "Guess the move",
     *       "createdAt": 1463756350225,
     *       "updatedAt": 1469965025205
     *     } */
    StudyMetadata: {
      /** @description The study ID */
      id?: string;
      /** @description The study name */
      name?: string;
      /**
       * Format: int64
       * @description The study creation date
       */
      createdAt?: number;
      /**
       * Format: int64
       * @description The study last update date
       */
      updatedAt?: number;
    };
    BroadcastTour: {
      id: string;
      name: string;
      slug: string;
      /** @example 1722169800000 */
      createdAt: number;
      /**
       * @description Start and end dates of the tournament, as Unix timestamps in milliseconds
       * @example [
       *       1722169800000,
       *       1722666600000
       *     ]
       */
      dates?: number[];
      /** @description Additional display information about the tournament */
      info?: {
        /**
         * Format: uri
         * @description Official website. External website URL
         */
        website?: string;
        /** @description Featured players */
        players?: string;
        /** @description Tournament location */
        location?: string;
        /** @description Time control */
        tc?: string;
        /**
         * @description FIDE rating category
         * @enum {string}
         */
        fideTc?: "standard" | "rapid" | "blitz";
        /** @description Timezone of the tournament. Example: `America/New_York`.
         *     See [list of possible timezone identifiers](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for more.
         *      */
        timeZone?: string;
        /**
         * Format: uri
         * @description Official standings website. External website URL
         */
        standings?: string;
        /** @description Tournament format */
        format?: string;
      };
      /** @description Used to designate featured tournaments on Lichess */
      tier?: number;
      /** Format: uri */
      image?: string;
      /** @description Full tournament description in markdown format, or in HTML if the html=1 query parameter is set. */
      description?: string;
      leaderboard?: boolean;
      teamTable?: boolean;
      /** Format: uri */
      url: string;
    };
    BroadcastGroupTour: {
      name?: string;
      id?: string;
    };
    BroadcastGroup: {
      name?: string;
      tours?: components["schemas"]["BroadcastGroupTour"][];
    };
    BroadcastRoundInfo: {
      id: string;
      name: string;
      slug: string;
      /** Format: int64 */
      createdAt: number;
      ongoing?: boolean;
      /** Format: int64 */
      startsAt?: number;
      /** @description The start date/time is unknown and the round will start automatically when the previous round completes */
      startsAfterPrevious?: boolean;
      /** Format: int64 */
      finishedAt?: number;
      finished?: boolean;
      /** Format: uri */
      url: string;
      /** Format: int64 */
      delay?: number;
    };
    BroadcastWithRounds: {
      tour: components["schemas"]["BroadcastTour"];
      group?: components["schemas"]["BroadcastGroup"];
      rounds: components["schemas"]["BroadcastRoundInfo"][];
      defaultRoundId?: string;
    };
    BroadcastWithLastRound: {
      group?: string;
      tour?: components["schemas"]["BroadcastTour"];
      round?: components["schemas"]["BroadcastRoundInfo"];
    };
    BroadcastTop: {
      active?: components["schemas"]["BroadcastWithLastRound"][];
      upcoming?: components["schemas"]["BroadcastWithLastRound"][];
      past?: {
        /** @example 4 */
        currentPage?: number;
        /** @example 20 */
        maxPerPage?: number;
        currentPageResults?: components["schemas"]["BroadcastWithLastRound"][];
        /** @example 3 */
        previousPage?: number | null;
        /** @example 5 */
        nextPage?: number | null;
      };
    };
    BroadcastByUser: {
      tour: components["schemas"]["BroadcastTour"];
    };
    BroadcastForm: {
      /** @description Name of the broadcast tournament.
       *
       *     Example: `Sinquefield Cup`
       *      */
      name: string;
      /** @description Tournament format.
       *     Example: `"8-player round-robin" or "5-round Swiss"`
       *      */
      "info.format"?: string;
      /** @description Tournament Location
       *      */
      "info.location"?: string;
      /** @description Time control.
       *     Example: `"Classical" or "Rapid" or "Rapid & Blitz"`
       *      */
      "info.tc"?: string;
      /**
       * @description FIDE rating category. Which FIDE ratings to use
       *
       * @enum {string}
       */
      "info.fideTc"?: "standard" | "rapid" | "blitz";
      /** @description Timezone of the tournament. Example: `America/New_York`.
       *     See [list of possible timezone identifiers](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for more.
       *      */
      "info.timeZone"?: string;
      /** @description Mention up to 4 of the best players participating.
       *      */
      "info.players"?: string;
      /**
       * Format: uri
       * @description Official website. External website URL
       *
       */
      "info.website"?: string;
      /**
       * Format: uri
       * @description Official Standings. External website URL, e.g. chess-results.com, info64.org
       *
       */
      "info.standings"?: string;
      /** @description Optional long description of the broadcast. Markdown is supported.
       *      */
      markdown?: string;
      /**
       * @description Show players scores based on game results
       *
       * @default true
       */
      showScores?: boolean;
      /**
       * @description Show player's rating diffs
       *
       * @default true
       */
      showRatingDiffs?: boolean;
      /**
       * @description Show a team leaderboard. Requires WhiteTeam and BlackTeam PGN tags.
       *
       * @default false
       */
      teamTable?: boolean;
      /** @description Optional replace player names, ratings and titles.
       *
       *     One line per player, formatted as such:
       *
       *     ```txt
       *     player name = FIDE ID
       *     ```
       *
       *     Example:
       *
       *     ```txt
       *     Magnus Carlsen = 1503014
       *     ```
       *
       *     Player names ignore case and punctuation, and match all possible combinations of 2 words: "Jorge Rick Vito" will match "Jorge Rick", "jorge vito", "Rick, Vito", etc.
       *
       *     If the player is NM or WNM, you can:
       *
       *     ```txt
       *     Player Name = FIDE ID / Title
       *     ```
       *
       *     Alternatively, you may set tags manually, like so:
       *
       *     ```txt
       *     player name / rating / title / new name
       *     ```
       *
       *     All values are optional. Example:
       *     ```txt
       *     Magnus Carlsen / 2863 / GM
       *     YouGotLittUp / 1890 / / Louis Litt
       *     ```
       *      */
      players?: string;
      /** @description Optional: assign players to teams
       *
       *     One line per player, formatted as such:
       *     ```txt
       *     Team name; Fide Id or Player name
       *     ```
       *
       *     Example:
       *     ```txt
       *     Team Cats ; 3408230
       *     Team Dogs ; Scooby Doo
       *     ```
       *
       *     By default the PGN tags WhiteTeam and BlackTeam are used.
       *      */
      teams?: string;
      /**
       * @description Optional, for Lichess admins only, used to feature on /broadcast.
       *
       *     * `3` for Official: normal tier
       *     * `4` for Official: high tier
       *     * `5` for Official: best tier
       *     * `-1` for Private
       *
       * @enum {integer}
       */
      tier?: 3 | 4 | 5 | -1;
    };
    BroadcastPlayerEntry: {
      /** @example Hernandez Riera, Jose */
      name?: string;
      /** @example 2.5 */
      score?: number;
      /** @example 7 */
      played?: number;
      /** @example 2149 */
      rating?: number;
      /** @example -5 */
      ratingDiff?: number;
      /** @example 2138 */
      performance?: number;
      /** @example FM */
      title?: string;
      /** @example 3408230 */
      fideId?: number;
      /** @example CHI */
      fed?: string;
    };
    /** @description Name of the broadcast round.
     *     Example: `Round 1`
     *      */
    BroadcastRoundFormName: string;
    BroadcastRoundForm: (
      | {
          name: components["schemas"]["BroadcastRoundFormName"];
        }
      | {
          name: components["schemas"]["BroadcastRoundFormName"];
          /**
           * Format: uri
           * @description URL that Lichess will poll to get updates about the games. It must be publicly accessible from the Internet.
           *
           *     Example:
           *     ```txt
           *     https://myserver.org/myevent/round-10/games.pgn
           *     ```
           *
           */
          syncUrl: string;
          /** @description Filter games by round number
           *
           *     Optional, only keep games from the source that match a round number.
           *     It uses the PGN **Round** tag. These would match round 3:
           *     ```txt
           *     [Round "3"]
           *     [Round "3.1"]
           *     ```
           *     If you set a round number, then games without a **Round** tag are dropped.
           *
           *     It only works if you chose `syncUrl` or `syncUrls` as the source.
           *      */
          onlyRound?: number;
          /** @description Select slices of the games
           *
           *     Optional. Select games based on their position in the source.
           *     ```txt
           *     1           only select the first board
           *     1-4         only select the first 4 boards
           *     1,2,3,4     same as above, first 4 boards
           *     11-15,21-25 boards 11 to 15, and boards 21 to 25
           *     2,3,7-9     boards 2, 3, 7, 8, and 9
           *     ```
           *     Slicing is done after filtering by round number.
           *
           *     It only works if you chose `syncUrl` or `syncUrls` as the source.
           *      */
          slices?: string;
        }
      | {
          name: components["schemas"]["BroadcastRoundFormName"];
          /** @description URLs that Lichess will poll to get updates about the games, separated by newlines. They must be publicly accessible from the Internet.
           *
           *     Example:
           *     ```txt
           *     https://myserver.org/myevent/round-10/game-1.pgn
           *     https://myserver.org/myevent/round-10/game-2.pgn
           *     ```
           *      */
          syncUrls: string;
          /** @description Filter games by round number
           *
           *     Optional, only keep games from the source that match a round number.
           *     It uses the PGN **Round** tag. These would match round 3:
           *     ```txt
           *     [Round "3"]
           *     [Round "3.1"]
           *     ```
           *     If you set a round number, then games without a **Round** tag are dropped.
           *
           *     It only works if you chose `syncUrl` or `syncUrls` as the source.
           *      */
          onlyRound?: number;
          /** @description Select slices of the games
           *
           *     Optional. Select games based on their position in the source.
           *     ```txt
           *     1           only select the first board
           *     1-4         only select the first 4 boards
           *     1,2,3,4     same as above, first 4 boards
           *     11-15,21-25 boards 11 to 15, and boards 21 to 25
           *     2,3,7-9     boards 2, 3, 7, 8, and 9
           *     ```
           *     Slicing is done after filtering by round number.
           *
           *     It only works if you chose `syncUrl` or `syncUrls` as the source.
           *      */
          slices?: string;
        }
      | {
          name: components["schemas"]["BroadcastRoundFormName"];
          /** @description Lichess game IDs - Up to 64 Lichess game IDs, separated by spaces.
           *      */
          syncIds: string;
        }
      | {
          name: components["schemas"]["BroadcastRoundFormName"];
          /** @description Up to 100 Lichess usernames, separated by spaces
           *      */
          syncUsers: string;
        }
    ) & {
      /**
       * Format: int64
       * @description Timestamp in milliseconds of broadcast round start. Leave empty to manually start the broadcast round.
       *     Example: `1356998400070`
       *
       */
      startsAt?: number;
      /**
       * @description The start date is unknown, and the round will start automatically when the previous round completes.
       *
       * @default false
       */
      startsAfterPrevious?: boolean;
      /** @description Delay in seconds for movements to appear on the broadcast. Leave it empty if you don't need it.
       *     Example: `900` (15 min)
       *      */
      delay?: number;
      /**
       * @description Lichess can usually detect the round status, but you can also set it manually if needed.
       *
       * @default new
       * @enum {string}
       */
      status?: "new" | "started" | "finished";
      /** @description (Only for Admins) Waiting time for each poll.
       *      */
      period?: number;
    };
    BroadcastRoundStudyInfo: {
      /** @description Whether the currently authenticated user has permission to update the study */
      writeable?: boolean;
    };
    /** @example {
     *       "round": {
     *         "createdAt": 1717344905926,
     *         "id": "n8JeQIeY",
     *         "name": "round 1",
     *         "slug": "round-1",
     *         "url": "https://lichess.org/broadcast/new-name/round-1/n8JeQIeY"
     *       },
     *       "study": {
     *         "writeable": true
     *       },
     *       "tour": {
     *         "createdAt": 1717342164861,
     *         "description": "test",
     *         "id": "HdRP6fce",
     *         "name": "New Name",
     *         "slug": "new-name",
     *         "url": "https://lichess.org/broadcast/new-name/HdRP6fce"
     *       }
     *     } */
    BroadcastRoundNew: {
      round: components["schemas"]["BroadcastRoundInfo"];
      tour: components["schemas"]["BroadcastTour"];
      study: components["schemas"]["BroadcastRoundStudyInfo"];
    };
    BroadcastRoundGame: {
      id: string;
      name: string;
      fen?: string;
      players?: {
        name?: string;
        title?: string;
        rating?: number;
        clock?: number;
        fed?: string;
      }[];
      lastMove?: string;
      thinkTime?: number;
      /**
       * @description The result of the game
       * @enum {string}
       */
      status?: "*" | "1-0" | "0-1" | "-";
    };
    BroadcastRound: {
      round: components["schemas"]["BroadcastRoundInfo"];
      tour: components["schemas"]["BroadcastTour"];
      study: components["schemas"]["BroadcastRoundStudyInfo"];
      games: components["schemas"]["BroadcastRoundGame"][];
      group?: components["schemas"]["BroadcastGroup"];
    };
    BroadcastPgnPushTags: {
      [key: string]: string;
    };
    /** @example {
     *       "games": [
     *         {
     *           "tags": {
     *             "White": "Rasmus Svane",
     *             "Black": "Rajat Makkar",
     *             "BlackElo": "2453",
     *             "BlackTeam": "France",
     *             "BlackTitle": "FM",
     *             "WhiteTeam": "Germany",
     *             "Result": "1-0",
     *             "WhiteElo": "2632",
     *             "WhiteTitle": "GM"
     *           },
     *           "moves": 2
     *         },
     *         {
     *           "tags": {
     *             "White": "Joseph Girel",
     *             "Black": "Matthias Bluebaum",
     *             "BlackElo": "2658",
     *             "BlackTeam": "Germany",
     *             "BlackTitle": "GM",
     *             "WhiteTeam": "France",
     *             "Result": "0-1",
     *             "WhiteElo": "2484",
     *             "WhiteTitle": "IM"
     *           },
     *           "error": "No move found: Pawn a8"
     *         }
     *       ]
     *     } */
    BroadcastPgnPush: {
      games: {
        tags: components["schemas"]["BroadcastPgnPushTags"];
        moves?: number;
        error?: string;
      }[];
    };
    /** @example {
     *       "round": {
     *         "id": "n8JeQIeY",
     *         "name": "round 1",
     *         "slug": "round-1",
     *         "createdAt": 1717344905926,
     *         "url": "https://lichess.org/broadcast/new-name/round-1/n8JeQIeY"
     *       },
     *       "tour": {
     *         "id": "HdRP6fce",
     *         "name": "New Name",
     *         "slug": "new-name",
     *         "description": "test",
     *         "createdAt": 1717342164861,
     *         "url": "https://lichess.org/broadcast/new-name/HdRP6fce"
     *       },
     *       "study": {
     *         "writeable": true
     *       }
     *     } */
    BroadcastMyRound: {
      round: components["schemas"]["BroadcastRoundInfo"];
      tour: components["schemas"]["BroadcastTour"];
      study: components["schemas"]["BroadcastRoundStudyInfo"];
    };
    FIDEPlayer: {
      /** @example 35009192 */
      id: number;
      /** @example Erigaisi Arjun */
      name: string;
      title?: components["schemas"]["Title"];
      /** @example IND */
      federation: string;
      /** @example 2003 */
      year?: number;
      /** @example true */
      inactive?: boolean;
      /** @example 2797 */
      standard?: number;
      /** @example 2698 */
      rapid?: number;
      /** @example 2738 */
      blitz?: number;
    };
    Simul: {
      id: string;
      host: components["schemas"]["LightUser"] & {
        rating?: number;
        provisional?: boolean;
        gameId?: string;
        online?: boolean;
      };
      name: string;
      fullName: string;
      variants: {
        key?: components["schemas"]["VariantKey"];
        icon?: string;
        name?: string;
      }[];
      isCreated: boolean;
      isFinished: boolean;
      isRunning: boolean;
      text?: string;
      estimatedStartAt?: number;
      startedAt?: number;
      finishedAt?: number;
      nbApplicants: number;
      nbPairings: number;
    };
    Team: {
      id: string;
      name: string;
      description?: string;
      flair?: components["schemas"]["Flair"];
      leader?: components["schemas"]["LightUser"];
      leaders?: components["schemas"]["LightUser"][];
      nbMembers?: number;
      open?: boolean;
      joined?: boolean;
      requested?: boolean;
    };
    TeamPaginatorJson: {
      /** @example 4 */
      currentPage?: number;
      /** @example 15 */
      maxPerPage?: number;
      currentPageResults?: components["schemas"]["Team"][];
      /** @example 205194 */
      nbResults?: number;
      /** @example 3 */
      previousPage?: number | null;
      /** @example 5 */
      nextPage?: number | null;
      /** @example 13680 */
      nbPages?: number;
    };
    /**
     * @description The current state of the arena tournament
     * @example created
     * @enum {string}
     */
    ArenaStatusName: "created" | "started" | "finished";
    TeamRequest: {
      /** @example coders */
      teamId?: string;
      /** @example thibault */
      userId?: string;
      /** @example 1514505150384 */
      date?: number;
      /** @example Hello, I would like to join the team! */
      message?: string;
    };
    TeamRequestWithUser: {
      request?: components["schemas"]["TeamRequest"];
      user?: components["schemas"]["User"];
    };
    /** @example {
     *       "users": {
     *         "neio": 201.5,
     *         "thibault": 144.5
     *       },
     *       "nbGames": 346,
     *       "matchup": {
     *         "users": {
     *           "neio": 44,
     *           "thibault": 43
     *         },
     *         "nbGames": 87
     *       }
     *     } */
    Crosstable: unknown;
    LightUserOnline: components["schemas"]["LightUser"] & {
      online?: boolean;
    };
    UserNote: {
      from?: components["schemas"]["LightUser"];
      to?: components["schemas"]["LightUser"];
      /** @example This is a note */
      text?: string;
      /**
       * Format: int64
       * @example 1290415680000
       */
      date?: number;
    };
    /** @example {
     *       "fullId": "9NaCTu2vz1c4",
     *       "gameId": "9NaCTu2v",
     *       "fen": "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
     *       "color": "white",
     *       "lastMove": "",
     *       "source": "friend",
     *       "status": {
     *         "id": 20,
     *         "name": "started"
     *       },
     *       "variant": {
     *         "key": "standard",
     *         "name": "Standard"
     *       },
     *       "speed": "blitz",
     *       "perf": "blitz",
     *       "rated": false,
     *       "hasMoved": false,
     *       "opponent": {
     *         "id": "mary",
     *         "username": "Mary",
     *         "rating": 1007
     *       },
     *       "isMyTurn": true,
     *       "secondsLeft": 300,
     *       "compat": {
     *         "bot": false,
     *         "board": true
     *       },
     *       "id": "9NaCTu2v"
     *     } */
    GameEventInfo: {
      fullId?: string;
      gameId?: string;
      fen?: string;
      /** @enum {string} */
      color?: "white" | "black";
      lastMove?: string;
      source?: components["schemas"]["GameSource"];
      status?: {
        /** @enum {integer} */
        id?: 10 | 20 | 25 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 60;
        name?: components["schemas"]["GameStatus"];
      };
      variant?: {
        key?: string;
        name?: string;
      };
      speed?: components["schemas"]["Speed"];
      perf?: string;
      rated?: boolean;
      hasMoved?: boolean;
      opponent?: {
        id?: string;
        username?: string;
        rating?: number;
      };
      isMyTurn?: boolean;
      secondsLeft?: number;
      compat?: {
        bot?: boolean;
        board?: boolean;
      };
      id?: string;
    };
    GameStartEvent: {
      /** @constant */
      type?: "gameStart";
      game?: components["schemas"]["GameEventInfo"];
    };
    GameFinishEvent: {
      /** @constant */
      type?: "gameFinish";
      game?: components["schemas"]["GameEventInfo"];
    };
    ChallengeUser: {
      rating?: number;
      provisional?: boolean;
      online?: boolean;
      lag?: number;
    } & components["schemas"]["LightUser"];
    /** @example {
     *       "id": "H9fIRZUk",
     *       "url": "https://lichess.org/H9fIRZUk",
     *       "status": "created",
     *       "challenger": {
     *         "id": "bot1",
     *         "name": "Bot1",
     *         "rating": 1500,
     *         "title": "BOT",
     *         "provisional": true,
     *         "online": true,
     *         "lag": 4
     *       },
     *       "destUser": {
     *         "id": "bobby",
     *         "name": "Bobby",
     *         "rating": 1635,
     *         "title": "GM",
     *         "provisional": true,
     *         "online": true,
     *         "lag": 4
     *       },
     *       "variant": {
     *         "key": "standard",
     *         "name": "Standard",
     *         "short": "Std"
     *       },
     *       "rated": true,
     *       "speed": "rapid",
     *       "timeControl": {
     *         "type": "clock",
     *         "limit": 600,
     *         "increment": 0,
     *         "show": "10+0"
     *       },
     *       "color": "random",
     *       "finalColor": "black",
     *       "perf": {
     *         "icon": "",
     *         "name": "Rapid"
     *       },
     *       "direction": "out"
     *     } */
    ChallengeJson: {
      id: string;
      /** Format: uri */
      url: string;
      /** @enum {string} */
      status: "created" | "offline" | "canceled" | "declined" | "accepted";
      challenger: components["schemas"]["ChallengeUser"];
      destUser: components["schemas"]["ChallengeUser"] | null;
      variant: components["schemas"]["Variant"];
      rated: boolean;
      speed: components["schemas"]["Speed"];
      timeControl:
        | {
            /** @example clock */
            type?: string;
            limit?: number;
            increment?: number;
            /** @example 5+2 */
            show?: string;
          }
        | {
            /** @example correspondence */
            type?: string;
            daysPerTurn?: number;
          }
        | {
            /** @example unlimited */
            type?: string;
          };
      /** @enum {string} */
      color: "white" | "black" | "random";
      /** @enum {string} */
      finalColor?: "white" | "black";
      perf: {
        icon?: string;
        name?: string;
      };
      /** @enum {string} */
      direction?: "in" | "out";
      initialFen?: string;
      /** @description Human readable, possibly translated reason why the challenge was declined. */
      declineReason?: string;
      /** @description Untranslated, computer-matchable reason why the challenge was declined. */
      declineReasonKey?: string;
    };
    ChallengeEvent: {
      /** @constant */
      type?: "challenge";
      challenge?: components["schemas"]["ChallengeJson"];
    };
    ChallengeCanceledEvent: {
      /** @constant */
      type?: "challengeCanceled";
      challenge?: components["schemas"]["ChallengeJson"];
    };
    /** @example {
     *       "id": "VU0nyvsW"
     *     } */
    ChallengeCanceledJson: {
      id?: string;
    };
    ChallengeDeclinedEvent: {
      /** @constant */
      type?: "challengeDeclined";
      challenge?: components["schemas"]["ChallengeCanceledJson"];
    };
    GameEventPlayer: {
      aiLevel?: number;
      id?: string;
      name?: string;
      title?: string | null;
      rating?: number;
      provisional?: boolean;
    };
    /** @example {
     *       "type": "gameState",
     *       "moves": "e2e4 c7c5 f2f4 d7d6 g1f3 b8c6 f1c4 g8f6 d2d3 g7g6 e1g1 f8g7 b1c3",
     *       "wtime": 7598040,
     *       "btime": 8395220,
     *       "winc": 10000,
     *       "binc": 10000,
     *       "wdraw": false,
     *       "bdraw": false,
     *       "wtakeback": false,
     *       "btakeback": false,
     *       "status": "started"
     *     } */
    GameStateEvent: {
      /** @constant */
      type: "gameState";
      /** @description Current moves in UCI format */
      moves: string;
      /** @description Integer of milliseconds White has left on the clock */
      wtime: number;
      /** @description Integer of milliseconds Black has left on the clock */
      btime: number;
      /** @description Integer of White Fisher increment. */
      winc: number;
      /** @description Integer of Black Fisher increment. */
      binc: number;
      status: components["schemas"]["GameStatus"];
      /** @description Color of the winner, if any */
      winner?: string;
      /** @description true if white is offering draw, else omitted */
      wdraw?: boolean;
      /** @description true if black is offering draw, else omitted */
      bdraw?: boolean;
      /** @description true if white is proposing takeback, else omitted */
      wtakeback?: boolean;
      /** @description true if black is proposing takeback, else omitted */
      btakeback?: boolean;
    };
    /** @example {
     *       "id": "BEOucQJo",
     *       "variant": {
     *         "key": "standard",
     *         "name": "Standard",
     *         "short": "Std"
     *       },
     *       "speed": "rapid",
     *       "perf": {
     *         "name": "Rapid"
     *       },
     *       "rated": false,
     *       "createdAt": 1745112707998,
     *       "white": {
     *         "id": "bobby",
     *         "name": "Bobby",
     *         "title": null,
     *         "rating": 1751
     *       },
     *       "black": {
     *         "id": "mary",
     *         "name": "Mary",
     *         "title": null,
     *         "rating": 1021
     *       },
     *       "initialFen": "startpos",
     *       "clock": {
     *         "initial": 900000,
     *         "increment": 0
     *       },
     *       "type": "gameFull",
     *       "state": {
     *         "type": "gameState",
     *         "moves": "d2d3",
     *         "wtime": 900000,
     *         "btime": 900000,
     *         "winc": 0,
     *         "binc": 0,
     *         "status": "started"
     *       }
     *     } */
    GameFullEvent: {
      /** @constant */
      type: "gameFull";
      id: string;
      variant: components["schemas"]["Variant"];
      clock: {
        /**
         * Format: int64
         * @description Initial time in milliseconds
         */
        initial?: number;
        /**
         * Format: int64
         * @description Increment time in milliseconds
         */
        increment?: number;
      };
      speed: components["schemas"]["Speed"];
      perf: {
        /** @description Translated perf name (e.g. "Classical" or "Blitz") */
        name?: string;
      };
      rated: boolean;
      /** Format: int64 */
      createdAt: number;
      white: components["schemas"]["GameEventPlayer"];
      black: components["schemas"]["GameEventPlayer"];
      /** @default startpos */
      initialFen: string;
      state: components["schemas"]["GameStateEvent"];
      tournamentId?: string;
    };
    /** @example {
     *       "type": "chatLine",
     *       "username": "thibault",
     *       "text": "Good luck, have fun",
     *       "room": "player"
     *     } */
    ChatLineEvent: {
      /** @constant */
      type: "chatLine";
      /** @enum {string} */
      room: "player" | "spectator";
      username: string;
      text: string;
    };
    /** @example {
     *       "type": "opponentGone",
     *       "gone": true,
     *       "claimWinInSeconds": 8
     *     } */
    OpponentGone: {
      /** @constant */
      type: "opponentGone";
      gone: boolean;
      claimWinInSeconds?: number;
    };
    /** @example {
     *       "error": "Not found."
     *     } */
    NotFound: {
      error?: string;
    };
    /** @example [
     *       {
     *         "text": "Takeback sent",
     *         "user": "lichess"
     *       },
     *       {
     *         "text": "Takeback accepted",
     *         "user": "lichess"
     *       },
     *       {
     *         "text": "Good game, well played",
     *         "user": "thibault"
     *       }
     *     ] */
    GameChat: unknown;
    /** @example {
     *       "id": "3gH5lybT",
     *       "url": "https://lichess.org/3gH5lybT",
     *       "status": "created",
     *       "challenger": null,
     *       "destUser": null,
     *       "variant": {
     *         "key": "standard",
     *         "name": "Standard",
     *         "short": "Std"
     *       },
     *       "rated": false,
     *       "speed": "rapid",
     *       "timeControl": {
     *         "type": "clock",
     *         "limit": 600,
     *         "increment": 5,
     *         "show": "10+5"
     *       },
     *       "color": "random",
     *       "finalColor": "black",
     *       "perf": {
     *         "icon": "",
     *         "name": "Rapid"
     *       },
     *       "open": {},
     *       "urlWhite": "https://lichess.org/3gH5lybT?color=white",
     *       "urlBlack": "https://lichess.org/3gH5lybT?color=black"
     *     } */
    ChallengeOpenJson: {
      id: string;
      /** Format: uri */
      url: string;
      /** @enum {string} */
      status: "created" | "offline" | "canceled" | "declined" | "accepted";
      challenger: null;
      destUser: null;
      variant: components["schemas"]["Variant"];
      rated: boolean;
      speed: components["schemas"]["Speed"];
      timeControl:
        | {
            /** @example clock */
            type?: string;
            limit?: number;
            increment?: number;
            /** @example 5+2 */
            show?: string;
          }
        | {
            /** @example correspondence */
            type?: string;
            daysPerTurn?: number;
          }
        | {
            /** @example unlimited */
            type?: string;
          };
      /** @enum {string} */
      color: "white" | "black" | "random";
      /** @enum {string} */
      finalColor?: "white" | "black";
      perf: {
        icon?: string;
        name?: string;
      };
      initialFen?: string;
      urlWhite: string;
      urlBlack: string;
      open: {
        /** @description An optional array of two user ids. If set, only these users will be allowed to join the game. The first username gets the white pieces. */
        userIds?: string[];
      };
    };
    /** @example {
     *       "id": "RVAcwgg7",
     *       "games": [
     *         {
     *           "id": "NKop9IyD",
     *           "black": "lizen1",
     *           "white": "thibault"
     *         },
     *         {
     *           "id": "KT8374ut",
     *           "black": "lizen3",
     *           "white": "lizen2"
     *         },
     *         {
     *           "id": "wInQr8Sk",
     *           "black": "lizen5",
     *           "white": "lizen4"
     *         }
     *       ],
     *       "variant": "standard",
     *       "clock": {
     *         "increment": 0,
     *         "limit": 300
     *       },
     *       "pairAt": 1612289869919,
     *       "pairedAt": null,
     *       "rated": false,
     *       "startClocksAt": 1612200422971,
     *       "scheduledAt": 1612203514628
     *     } */
    BulkPairing: unknown;
    /** @example {
     *       "fen": "r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R",
     *       "knodes": 106325,
     *       "depth": 29,
     *       "pvs": [
     *         {
     *           "moves": "d1e2 d8e7 a2a4 a7a6 b5c4 d7d6 d2d3 g8f6 c1e3 c6a5",
     *           "cp": 41
     *         },
     *         {
     *           "moves": "c2c3 a7a6 b5a4 g8f6 d2d3 b7b5 a4b3 h7h6 a2a4 c8b7",
     *           "cp": 39
     *         },
     *         {
     *           "moves": "d2d3 d8f6 c2c3 a7a6 b5a4 f8c5 d3d4 c5a7 c1e3 g8e7",
     *           "cp": 37
     *         }
     *       ]
     *     } */
    CloudEval: {
      depth: number;
      fen: string;
      knodes: number;
      pvs: (
        | {
            /** @description Evaluation in centi-pawns, from White's point of view */
            cp: number;
            /** @description Variation in UCI notation */
            moves: string;
          }
        | {
            /** @description Evaluation in moves to mate, from White's point of view */
            mate: number;
            /** @description Variation in UCI notation */
            moves: string;
          }
      )[];
    };
    /**
     * @default chess
     * @example chess
     * @enum {string}
     */
    UciVariant:
      | "chess"
      | "crazyhouse"
      | "antichess"
      | "atomic"
      | "horde"
      | "kingofthehill"
      | "racingkings"
      | "3check";
    ExternalEngine: {
      /**
       * @description Unique engine registration ID.
       * @example eei_aTKImBJOnv6j
       */
      id: string;
      /**
       * @description Display name of the engine.
       * @example Stockfish 15
       */
      name: string;
      /**
       * @description A secret token that can be used to
       *     [*request* analysis](#tag/External-engine/operation/apiExternalEngineAnalyse)
       *     from this external engine.
       *
       * @example ees_mdF2hK0hlKGSPeC6
       */
      clientSecret: string;
      /**
       * @description The user this engine has been registered for.
       * @example thibault
       */
      userId: string;
      /**
       * @description Maximum number of available threads.
       * @example 8
       */
      maxThreads: number;
      /**
       * @description Maximum available hash table size, in MiB.
       * @example 2048
       */
      maxHash: number;
      /**
       * @description List of supported chess variants.
       * @example [
       *       "chess"
       *     ]
       */
      variants: components["schemas"]["UciVariant"][];
      /** @description Arbitrary data that the engine provider can use for identification
       *     or bookkeeping.
       *
       *     Users can read this information, but updating it requires knowing
       *     or changing the `providerSecret`.
       *      */
      providerData?: string;
    };
    ExternalEngineRegistration: {
      /**
       * @description Display name of the engine.
       * @example Stockfish 15
       */
      name: string;
      /**
       * @description Maximum number of available threads.
       * @example 8
       */
      maxThreads: number;
      /**
       * @description Maximum available hash table size, in MiB.
       * @example 2048
       */
      maxHash: number;
      /** @description Optional list of supported chess variants. */
      variants?: components["schemas"]["UciVariant"][];
      /**
       * @description A random token that can be used to
       *     [wait for analysis requests](#tag/External-engine/operation/apiExternalEngineAcquire)
       *     and provide analysis.
       *
       *     The engine provider should securely generate a random string.
       *
       *     The token will not be readable again, even by the user.
       *
       *     The analysis provider can register multiple engines with the same
       *     token, even for different users, and wait for analysis requests
       *     from any of them. In this case, the request must not be made via
       *     CORS, so that the token is not revealed to any of the users.
       *
       * @example Dee3uwieZei9ahpaici9bee2yahsai0K
       */
      providerSecret: string;
      /** @description Arbitrary data that the engine provider can use for identification
       *     or bookkeeping.
       *
       *     Users can read this information, but updating it requires knowing
       *     or changing the `providerSecret`.
       *      */
      providerData?: string;
    };
    ExternalEngineWork: {
      /**
       * @description Arbitary string that identifies the analysis session.
       *     Providers may wish to clear the hash table between sessions.
       *
       * @example abcd1234
       */
      sessionId: string;
      /**
       * @description Number of threads to use for analysis.
       * @example 4
       */
      threads: number;
      /**
       * @description Hash table size to use for analysis, in MiB.
       * @example 128
       */
      hash: number;
      /**
       * @description Requested number of principal variations.
       * @example 1
       */
      multiPv: number;
      variant: components["schemas"]["UciVariant"];
      /**
       * @description Initial position of the game.
       * @example rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
       */
      initialFen: string;
      /**
       * @description List of moves played from the initial position, in UCI notation.
       * @example [
       *       "e2e4",
       *       "g8f6"
       *     ]
       */
      moves: string[];
      /** @description Amount of time to analyse the position, in milliseconds. */
      movetime?: number;
      /** @description Analysis target depth */
      depth?: number;
      /** @description Number of nodes to analyse in the position */
      nodes?: number;
    };
    /** @example {
     *       "error": "invalid_grant",
     *       "error_description": "hash of code_verifier does not match code_challenge"
     *     } */
    OAuthError: {
      /** @description The cause of the error. */
      error?: string;
      /** @description The reason why the request was rejected. */
      error_description?: string;
    };
    OpeningExplorerOpening: {
      eco: string;
      name: string;
    };
    OpeningExplorerGamePlayer: {
      name: string;
      rating: number;
    };
    OpeningExplorerMastersGame: {
      id: string;
      /** @enum {string|null} */
      winner: "white" | "black" | null;
      white: components["schemas"]["OpeningExplorerGamePlayer"];
      black: components["schemas"]["OpeningExplorerGamePlayer"];
      year: number;
      month?: string;
    };
    /** @example {
     *       "opening": {
     *         "eco": "D10",
     *         "name": "Slav Defense: Exchange Variation"
     *       },
     *       "white": 1828,
     *       "draws": 4904,
     *       "black": 1403,
     *       "moves": [
     *         {
     *           "uci": "c6d5",
     *           "san": "cxd5",
     *           "averageRating": 2414,
     *           "white": 1828,
     *           "draws": 4904,
     *           "black": 1402,
     *           "game": null,
     *           "opening": null
     *         },
     *         {
     *           "uci": "g8f6",
     *           "san": "Nf6",
     *           "averageRating": 2515,
     *           "white": 0,
     *           "draws": 0,
     *           "black": 1,
     *           "game": {
     *             "id": "1EErB5jc",
     *             "winner": "black",
     *             "black": {
     *               "name": "Dobrov, Vladimir",
     *               "rating": 2515
     *             },
     *             "white": {
     *               "name": "Drozdovskij, Yuri",
     *               "rating": 2509
     *             },
     *             "year": 2006,
     *             "month": "2006-01"
     *           },
     *           "opening": {
     *             "eco": "D06",
     *             "name": "Queen's Gambit Declined: Marshall Defense, Tan Gambit"
     *           }
     *         }
     *       ],
     *       "topGames": [
     *         {
     *           "uci": "c6d5",
     *           "id": "kN6d9l2i",
     *           "winner": "black",
     *           "black": {
     *             "name": "Anand, V.",
     *             "rating": 2785
     *           },
     *           "white": {
     *             "name": "Carlsen, M.",
     *             "rating": 2881
     *           },
     *           "year": 2014,
     *           "month": "2014-06"
     *         },
     *         {
     *           "uci": "c6d5",
     *           "id": "qeYPJL2y",
     *           "winner": "white",
     *           "black": {
     *             "name": "Carlsen, M.",
     *             "rating": 2843
     *           },
     *           "white": {
     *             "name": "So, W.",
     *             "rating": 2778
     *           },
     *           "year": 2018,
     *           "month": "2018-06"
     *         }
     *       ]
     *     } */
    OpeningExplorerMasters: {
      opening: components["schemas"]["OpeningExplorerOpening"] | null;
      white: number;
      draws: number;
      black: number;
      moves: {
        uci: string;
        san: string;
        averageRating: number;
        white: number;
        draws: number;
        black: number;
        game: components["schemas"]["OpeningExplorerMastersGame"] | null;
        opening: components["schemas"]["OpeningExplorerOpening"] | null;
      }[];
      topGames: ({
        uci: string;
      } & components["schemas"]["OpeningExplorerMastersGame"])[];
    };
    OpeningExplorerLichessGame: {
      id: string;
      /** @enum {string|null} */
      winner: "white" | "black" | null;
      speed: components["schemas"]["Speed"];
      white: components["schemas"]["OpeningExplorerGamePlayer"];
      black: components["schemas"]["OpeningExplorerGamePlayer"];
      year: number;
      month: string;
    };
    /** @example {
     *       "opening": {
     *         "eco": "D10",
     *         "name": "Slav Defense: Exchange Variation"
     *       },
     *       "white": 4164079,
     *       "draws": 405547,
     *       "black": 3668091,
     *       "moves": [
     *         {
     *           "uci": "c6d5",
     *           "san": "cxd5",
     *           "averageRating": 1801,
     *           "white": 3716043,
     *           "draws": 370963,
     *           "black": 3304807,
     *           "game": null,
     *           "opening": null
     *         },
     *         {
     *           "uci": "d8d5",
     *           "san": "Qxd5",
     *           "averageRating": 1658,
     *           "white": 195544,
     *           "draws": 14378,
     *           "black": 140001,
     *           "game": null,
     *           "opening": null
     *         }
     *       ],
     *       "recentGames": [
     *         {
     *           "uci": "c6d5",
     *           "id": "ilsfX0gq",
     *           "winner": "black",
     *           "speed": "blitz",
     *           "mode": "rated",
     *           "black": {
     *             "name": "captan64",
     *             "rating": 2201
     *           },
     *           "white": {
     *             "name": "ElsaPato33",
     *             "rating": 2324
     *           },
     *           "year": 2024,
     *           "month": "2024-10"
     *         }
     *       ],
     *       "topGames": [
     *         {
     *           "uci": "g8f6",
     *           "id": "EqJcFS1j",
     *           "winner": "white",
     *           "speed": "ultraBullet",
     *           "mode": "rated",
     *           "black": {
     *             "name": "toivok",
     *             "rating": 2708
     *           },
     *           "white": {
     *             "name": "penguingim1",
     *             "rating": 2969
     *           },
     *           "year": 2018,
     *           "month": "2018-04"
     *         }
     *       ],
     *       "history": [
     *         {
     *           "month": "2013-01",
     *           "white": 60,
     *           "draws": 2,
     *           "black": 54
     *         },
     *         {
     *           "month": "2013-02",
     *           "white": 71,
     *           "draws": 8,
     *           "black": 75
     *         },
     *         {
     *           "month": "2013-03",
     *           "white": 83,
     *           "draws": 4,
     *           "black": 72
     *         }
     *       ]
     *     } */
    OpeningExplorerLichess: {
      opening: components["schemas"]["OpeningExplorerOpening"] | null;
      white: number;
      draws: number;
      black: number;
      moves: {
        uci: string;
        san: string;
        averageRating: number;
        white: number;
        draws: number;
        black: number;
        game: components["schemas"]["OpeningExplorerLichessGame"] | null;
        opening: components["schemas"]["OpeningExplorerOpening"] | null;
      }[];
      topGames: ({
        uci: string;
      } & components["schemas"]["OpeningExplorerLichessGame"])[];
      recentGames: ({
        uci: string;
      } & components["schemas"]["OpeningExplorerLichessGame"])[];
      history?: {
        month: string;
        white: number;
        draws: number;
        black: number;
      }[];
    };
    OpeningExplorerPlayerGame: {
      id: string;
      /** @enum {string|null} */
      winner: "white" | "black" | null;
      speed: components["schemas"]["Speed"];
      /** @enum {string} */
      mode: "rated" | "casual";
      white: components["schemas"]["OpeningExplorerGamePlayer"];
      black: components["schemas"]["OpeningExplorerGamePlayer"];
      year: number;
      month: string;
    };
    /** @example {
     *       "opening": {
     *         "eco": "D00",
     *         "name": "Queen's Pawn Game"
     *       },
     *       "queuePosition": 25,
     *       "white": 366,
     *       "draws": 23,
     *       "black": 279,
     *       "moves": [
     *         {
     *           "uci": "c2c4",
     *           "san": "c4",
     *           "averageOpponentRating": 1695,
     *           "performance": 1744,
     *           "white": 361,
     *           "draws": 23,
     *           "black": 272,
     *           "game": null,
     *           "opening": {
     *             "eco": "D06",
     *             "name": "Queen's Gambit"
     *           }
     *         },
     *         {
     *           "uci": "c2c3",
     *           "san": "c3",
     *           "averageOpponentRating": 1797,
     *           "performance": 1797,
     *           "white": 2,
     *           "draws": 0,
     *           "black": 2,
     *           "game": null,
     *           "opening": null
     *         },
     *         {
     *           "uci": "e2e4",
     *           "san": "e4",
     *           "averageOpponentRating": 1762,
     *           "performance": 1640,
     *           "white": 1,
     *           "draws": 0,
     *           "black": 2,
     *           "game": null,
     *           "opening": {
     *             "eco": "D00",
     *             "name": "Blackmar-Diemer Gambit"
     *           }
     *         },
     *         {
     *           "uci": "g1f3",
     *           "san": "Nf3",
     *           "averageOpponentRating": 1497,
     *           "performance": 1374,
     *           "white": 1,
     *           "draws": 0,
     *           "black": 2,
     *           "game": null,
     *           "opening": {
     *             "eco": "D02",
     *             "name": "Queen's Pawn Game: Zukertort Variation"
     *           }
     *         },
     *         {
     *           "uci": "h2h4",
     *           "san": "h4",
     *           "averageOpponentRating": 1674,
     *           "performance": 874,
     *           "white": 0,
     *           "draws": 0,
     *           "black": 1,
     *           "game": {
     *             "id": "9vA24xBn",
     *             "winner": "black",
     *             "speed": "bullet",
     *             "mode": "rated",
     *             "black": {
     *               "name": "MentalBlood",
     *               "rating": 1674
     *             },
     *             "white": {
     *               "name": "revoof",
     *               "rating": 1657
     *             },
     *             "year": 2020,
     *             "month": "2020-06"
     *           },
     *           "opening": null
     *         }
     *       ],
     *       "recentGames": [
     *         {
     *           "uci": "c2c4",
     *           "id": "ycZbWQZO",
     *           "winner": "white",
     *           "speed": "bullet",
     *           "mode": "rated",
     *           "black": {
     *             "name": "Winavesh",
     *             "rating": 1700
     *           },
     *           "white": {
     *             "name": "revoof",
     *             "rating": 1700
     *           },
     *           "year": 2024,
     *           "month": "2024-11"
     *         }
     *       ]
     *     } */
    OpeningExplorerPlayer: {
      opening: components["schemas"]["OpeningExplorerOpening"] | null;
      queuePosition: number;
      white: number;
      draws: number;
      black: number;
      moves: {
        uci: string;
        san: string;
        averageOpponentRating: number;
        performance: number;
        white: number;
        draws: number;
        black: number;
        game: components["schemas"]["OpeningExplorerPlayerGame"] | null;
        opening: components["schemas"]["OpeningExplorerOpening"] | null;
      }[];
      recentGames: ({
        uci: string;
      } & components["schemas"]["OpeningExplorerPlayerGame"])[];
    };
    /** @example [Event "Wch Blitz"]
     *     [Site "Astana"]
     *     [Date "2012.07.10"]
     *     [Round "23"]
     *     [White "Carlsen, Magnus"]
     *     [Black "Chadaev, Nikolay"]
     *     [Result "1-0"]
     *     [WhiteElo "2837"]
     *     [BlackElo "2580"]
     *
     *     1. e4 e5 2. f4 d5 3. exd5 exf4 4. Nf3 Nf6 5. c4 c6 6. d4 cxd5 7. c5 Nc6 8. Bb5 Be7 9. O-O O-O 10. Bxf4 Bg4 11. Nc3 Ne4 12. Qd3 Bf5 13. Qe3 Bf6 14. Bxc6 bxc6 15. Ne5 Bxe5 16. Bxe5 Bg6 17. Nxe4 Bxe4 18. Qg3 f6 19. Bd6 Re8 20. b4 Bg6 21. a4 a6 22. h4 Qd7 23. h5 Bxh5 24. Rxf6 Qg4 25. Qxg4 Bxg4 26. Rf4 Bh5 27. Raf1 h6 28. Be5 Ra7 29. b5 axb5 30. axb5 cxb5 31. c6 Raa8 32. c7 Kh7 33. Rb1 Be2 34. Rf7 Rg8 35. Re7 Bc4 36. Kh2 Rae8 37. Rd7 Ra8 38. Rb2 Raf8 39. g4 Ra8 40. Rf2 b4 41. Rff7 h5 42. Rxg7+ Rxg7 43. Rxg7+ 1-0
     *      */
    MasterGamePgn: unknown;
    Move: {
      /** @example h7h8q */
      uci?: string;
      /** @example h8=Q+ */
      san?: string;
      /** @enum {string} */
      category?:
        | "loss"
        | "unknown"
        | "syzygy-loss"
        | "maybe-loss"
        | "blessed-loss"
        | "draw"
        | "cursed-win"
        | "maybe-win"
        | "syzygy-win"
        | "win";
      /** @description DTZ50'' with rounding or null if unknown */
      dtz?: null | number;
      /** @description DTZ50'' (only if guaranteed to be not rounded) or null if unknown
       *      */
      precise_dtz?: null | number;
      /** @description Depth to Conversion (experimental) */
      dtc?: null | number;
      /** @description Depth To Mate (only for Standard positions with not more than 5 pieces) */
      dtm?: null | number;
      /** @description Depth To Win (only for Antichess positions with not more than 4 pieces) */
      dtw?: null | number;
      zeroing?: boolean;
      checkmate?: boolean;
      stalemate?: boolean;
      variant_win?: boolean;
      variant_loss?: boolean;
      insufficient_material?: boolean;
    };
    /** @example {
     *       "dtz": 1,
     *       "precise_dtz": 1,
     *       "dtc": null,
     *       "dtm": 17,
     *       "dtw": null,
     *       "checkmate": false,
     *       "stalemate": false,
     *       "variant_win": false,
     *       "variant_loss": false,
     *       "insufficient_material": false,
     *       "category": "win",
     *       "moves": [
     *         {
     *           "uci": "h7h8q",
     *           "san": "h8=Q+",
     *           "dtz": -2,
     *           "precise_dtz": -2,
     *           "dtc": null,
     *           "dtm": -16,
     *           "dtw": null,
     *           "zeroing": true,
     *           "checkmate": false,
     *           "stalemate": false,
     *           "variant_win": false,
     *           "variant_loss": false,
     *           "insufficient_material": false,
     *           "category": "loss"
     *         }
     *       ]
     *     } */
    TablebaseJson: {
      /**
       * @description `cursed-win` and `blessed-loss` means the 50-move rule prevents
       *     the decisive result.
       *
       *     `syzygy-win` and `syzygy-loss` means exact result is unknown due to
       *     [DTZ rounding](https://syzygy-tables.info/metrics#dtz), i.e., the
       *     win or loss could also be prevented by the 50-move rule if
       *     the user has deviated from the tablebase recommendation since the
       *     last pawn move or capture.
       *
       *     `maybe-win` and `maybe-loss` means the result with regard to the
       *     50-move rule is unknown because the DTC tablebase does not
       *     guarantee to reach a zeroing move as soon as possible.
       *
       * @enum {string}
       */
      category?:
        | "win"
        | "unknown"
        | "syzygy-win"
        | "maybe-win"
        | "cursed-win"
        | "draw"
        | "blessed-loss"
        | "maybe-loss"
        | "syzygy-loss"
        | "loss";
      /** @description [DTZ50'' with rounding](https://syzygy-tables.info/metrics#dtz) or null if unknown
       *      */
      dtz?: null | number;
      /** @description DTZ50'' (only if guaranteed to be not rounded) or null if unknown
       *      */
      precise_dtz?: null | number;
      /** @description Depth to Conversion (experimental) */
      dtc?: null | number;
      /** @description Depth To Mate (only for Standard positions with not more than 5 pieces) */
      dtm?: null | number;
      /** @description Depth To Win (only for Antichess positions with not more than 4 pieces) */
      dtw?: null | number;
      checkmate?: boolean;
      stalemate?: boolean;
      /** @description Only in chess variants */
      variant_win?: boolean;
      /** @description Only in chess variants */
      variant_loss?: boolean;
      insufficient_material?: boolean;
      /** @description Information about legal moves, best first */
      moves?: components["schemas"]["Move"][];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  apiUsersStatus: {
    parameters: {
      query: {
        /**
         * @description User IDs separated by commas. Up to 100 IDs.
         * @example thibault,maia1,maia5
         */
        ids: string;
        /**
         * @description Also return the network signal of the player, when available.
         *     It ranges from 1 (poor connection, lag > 500ms) to 4 (great connection, lag < 150ms)
         *     Defaults to `false` to preserve server resources.
         *
         * @example true
         */
        withSignal?: boolean;
        /**
         * @description Also return the ID of the game being played, if any, for each player, in a `playingId` field.
         *     Defaults to `false` to preserve server resources.
         *
         * @example true
         */
        withGameIds?: boolean;
        /**
         * @description Also return the id, time control and variant of the game being played, if any, for each player, in a `playing` field.
         *     Defaults to `false` to preserve server resources. Disables `withGameIds`.
         *
         * @example true
         */
        withGameMetas?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of users and their respective statuses. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            id: string;
            name: string;
            flair?: components["schemas"]["Flair"];
            title?: string;
            online?: boolean;
            playing?: boolean;
            streaming?: boolean;
            patron?: boolean;
          }[];
        };
      };
    };
  };
  player: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of variants with their respective top players. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Top10s"];
        };
      };
    };
  };
  playerTopNbPerfType: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description How many users to fetch */
        nb: number;
        /** @description The speed or variant */
        perfType:
          | "ultraBullet"
          | "bullet"
          | "blitz"
          | "rapid"
          | "classical"
          | "chess960"
          | "crazyhouse"
          | "antichess"
          | "atomic"
          | "horde"
          | "kingOfTheHill"
          | "racingKings"
          | "threeCheck";
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of top players for the variant. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/vnd.lichess.v3+json": components["schemas"]["Leaderboard"];
        };
      };
    };
  };
  apiUser: {
    parameters: {
      query?: {
        /** @description Include user trophies */
        trophies?: boolean;
      };
      header?: never;
      path: {
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The information of the user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["UserExtended"];
        };
      };
    };
  };
  apiUserRatingHistory: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The rating history of the user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["RatingHistory"];
        };
      };
    };
  };
  apiUserPerf: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        username: string;
        perf: components["schemas"]["PerfType"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The performance statistics of the user */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PerfStat"];
        };
      };
    };
  };
  apiUserActivity: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The activity feed of the user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["UserActivity"][];
        };
      };
    };
  };
  apiPuzzleDaily: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The daily puzzle. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PuzzleAndGame"];
        };
      };
    };
  };
  apiPuzzleId: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The puzzle ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The requested puzzle. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PuzzleAndGame"];
        };
      };
    };
  };
  apiPuzzleNext: {
    parameters: {
      query?: {
        /** @description The theme or opening to filter puzzles with.
         *
         *     Available themes are listed in [the lichess source code](https://github.com/ornicar/lila/blob/master/translation/source/puzzleTheme.xml).
         *      */
        angle?: string;
        /** @description The desired puzzle difficulty, relative to the authenticated user puzzle rating, or 1500 if anonymous. */
        difficulty?: "easiest" | "easier" | "normal" | "harder" | "hardest";
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The requested puzzle. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PuzzleAndGame"];
        };
      };
    };
  };
  apiPuzzleActivity: {
    parameters: {
      query?: {
        /** @description How many entries to download. Leave empty to download all activity. */
        max?: number;
        /** @description Download entries before this timestamp. Defaults to now. Use `before` and `max` for pagination. */
        before?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The puzzle activity of the logged in user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["PuzzleActivity"];
        };
      };
    };
  };
  apiPuzzleReplay: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description How many days to look back when aggregating puzzle results. 30 is sensible. */
        days: number;
        /** @description The theme or opening to filter puzzles with. */
        theme: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The requested puzzles to replay. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PuzzleReplay"];
        };
      };
      /** @description No puzzles to replay were found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** @example No puzzles to replay */
            error?: string;
          };
        };
      };
    };
  };
  apiPuzzleDashboard: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description How many days to look back when aggregating puzzle results. 30 is sensible. */
        days: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The puzzle dashboard of the logged in user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PuzzleDashboard"];
        };
      };
    };
  };
  apiStormDashboard: {
    parameters: {
      query?: {
        /** @description How many days of history to return */
        days?: number;
      };
      header?: never;
      path: {
        /** @description Username of the player */
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The storm dashboard of a player. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PuzzleStormDashboard"];
        };
      };
    };
  };
  racerPost: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The new puzzle race. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["PuzzleRacer"];
        };
      };
    };
  };
  apiUsers: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description User IDs separated by commas. */
    requestBody: {
      content: {
        /** @example thibault,maia1,maia5 */
        "text/plain": string;
      };
    };
    responses: {
      /** @description The list of users. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["User"][];
        };
      };
    };
  };
  accountMe: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The public information about the logged in user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["UserExtended"];
        };
      };
    };
  };
  accountEmail: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The email address of the logged in user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            email?: string;
          };
        };
      };
    };
  };
  account: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The preferences of the logged in user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            prefs?: components["schemas"]["UserPreferences"];
            /** @example en-GB */
            language?: string;
          };
        };
      };
    };
  };
  accountKid: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The kid mode status of the logged in user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            kid?: boolean;
          };
        };
      };
    };
  };
  accountKidPost: {
    parameters: {
      query: {
        /**
         * @description Kid mode status
         * @example true
         */
        v: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The kid mode status was set successfully for the logged in user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  timeline: {
    parameters: {
      query?: {
        /** @description Show events since this timestamp. */
        since?: number;
        /** @description Max number of events to fetch. */
        nb?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The events in the timeline of the logged in user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Timeline"];
        };
      };
    };
  };
  gamePgn: {
    parameters: {
      query?: {
        /** @description Include the PGN moves. */
        moves?: boolean;
        /** @description Include the full PGN within the JSON response, in a `pgn` field. */
        pgnInJson?: boolean;
        /** @description Include the PGN tags. */
        tags?: boolean;
        /** @description Include clock status when available.
         *     Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *     Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *      */
        clocks?: boolean;
        /** @description Include analysis evaluations and comments, when available.
         *     Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         *     Or in an `analysis` JSON field, depending on the response type.
         *      */
        evals?: boolean;
        /** @description Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *      */
        accuracy?: boolean;
        /** @description Include the opening name.
         *     Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *      */
        opening?: boolean;
        /** @description Plies which mark the beginning of the middlegame and endgame.
         *     Only available in JSON
         *      */
        division?: boolean;
        /** @description Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         *     Example: `5... g4? { (-0.98  0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *      */
        literate?: boolean;
        /** @description Add a `bookmarked: true` JSON field when the logged in user has bookmarked the game.
         *     The response type must be set to `application/x-ndjson` by the request `Accept` header.
         *      */
        withBookmarked?: boolean;
        /** @description URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN.
         *     Example: <https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt>
         *      */
        players?: string;
      };
      header?: never;
      path: {
        /** @description The game ID */
        gameId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The game representation. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["GamePgn"];
          "application/json": components["schemas"]["GameJson"];
        };
      };
    };
  };
  apiUserCurrentGame: {
    parameters: {
      query?: {
        /** @description Include the PGN moves. */
        moves?: boolean;
        /** @description Include the full PGN within the JSON response, in a `pgn` field. */
        pgnInJson?: boolean;
        /** @description Include the PGN tags. */
        tags?: boolean;
        /** @description Include clock status when available.
         *     Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *     Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *      */
        clocks?: boolean;
        /** @description Include analysis evaluations and comments, when available.
         *     Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         *     Or in an `analysis` JSON field, depending on the response type.
         *      */
        evals?: boolean;
        /** @description Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *      */
        accuracy?: boolean;
        /** @description Include the opening name.
         *     Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *      */
        opening?: boolean;
        /** @description Plies which mark the beginning of the middlegame and endgame.
         *     Only available in JSON
         *      */
        division?: boolean;
        /** @description Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         *     Example: `5... g4? { (-0.98  0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *      */
        literate?: boolean;
        /** @description URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN.
         *     Example: <https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt>
         *      */
        players?: string;
      };
      header?: never;
      path: {
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The ongoing (or last) game of a user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["GamePgn"];
          "application/json": components["schemas"]["GameJson"];
        };
      };
    };
  };
  apiGamesUser: {
    parameters: {
      query?: {
        /** @description Download games played since this timestamp. Defaults to account creation date. */
        since?: number;
        /** @description Download games played until this timestamp. Defaults to now. */
        until?: number;
        /** @description How many games to download. Leave empty to download all games. */
        max?: number;
        /** @description [Filter] Only games played against this opponent */
        vs?: string;
        /** @description [Filter] Only rated (`true`) or casual (`false`) games */
        rated?: boolean;
        /** @description [Filter] Only games in these speeds or variants.
         *     Multiple perf types can be specified, separated by a comma.
         *     Example: blitz,rapid,classical
         *      */
        perfType?: components["schemas"]["PerfType"] & unknown;
        /** @description [Filter] Only games played as this color. */
        color?: "white" | "black";
        /** @description [Filter] Only games with or without a computer analysis available */
        analysed?: boolean;
        /** @description Include the PGN moves. */
        moves?: boolean;
        /** @description Include the full PGN within the JSON response, in a `pgn` field. The response type must be set to `application/x-ndjson` by the request `Accept` header. */
        pgnInJson?: boolean;
        /** @description Include the PGN tags. */
        tags?: boolean;
        /** @description Include clock status when available.
         *     Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *     Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *      */
        clocks?: boolean;
        /** @description Include analysis evaluations and comments, when available.
         *     Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         *     Or in an `analysis` JSON field, depending on the response type.
         *      */
        evals?: boolean;
        /** @description Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *      */
        accuracy?: boolean;
        /** @description Include the opening name.
         *     Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *      */
        opening?: boolean;
        /** @description Plies which mark the beginning of the middlegame and endgame.
         *     Only available in JSON
         *      */
        division?: boolean;
        /** @description Ongoing games are delayed by a few seconds ranging from 3 to 60 depending on the time control, as to prevent cheat bots from using this API. */
        ongoing?: boolean;
        /** @description Include finished games. Set to `false` to only get ongoing games. */
        finished?: boolean;
        /** @description Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         *     Example: `5... g4? { (-0.98  0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *      */
        literate?: boolean;
        /** @description Include the FEN notation of the last position of the game.
         *     The response type must be set to `application/x-ndjson` by the request `Accept` header.
         *      */
        lastFen?: boolean;
        /** @description Add a `bookmarked: true` JSON field when the logged in user has bookmarked the game.
         *     The response type must be set to `application/x-ndjson` by the request `Accept` header.
         *      */
        withBookmarked?: boolean;
        /** @description URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN.
         *     Example: <https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt>
         *      */
        players?: string;
        /** @description Sort order of the games. */
        sort?: "dateAsc" | "dateDesc";
      };
      header?: never;
      path: {
        /** @description The user name. */
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The games of the user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["GamePgn"];
          "application/x-ndjson": components["schemas"]["GameJson"];
        };
      };
    };
  };
  gamesExportIds: {
    parameters: {
      query?: {
        /** @description Include the PGN moves. */
        moves?: boolean;
        /** @description Include the full PGN within the JSON response, in a `pgn` field. */
        pgnInJson?: boolean;
        /** @description Include the PGN tags. */
        tags?: boolean;
        /** @description Include clock status when available.
         *     Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *     Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *      */
        clocks?: boolean;
        /** @description Include analysis evaluations and comments, when available.
         *     Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         *     Or in an `analysis` JSON field, depending on the response type.
         *      */
        evals?: boolean;
        /** @description Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *      */
        accuracy?: boolean;
        /** @description Include the opening name.
         *     Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *      */
        opening?: boolean;
        /** @description Plies which mark the beginning of the middlegame and endgame.
         *     Only available in JSON
         *      */
        division?: boolean;
        /** @description Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         *     Example: `5... g4? { (-0.98  0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *      */
        literate?: boolean;
        /** @description URL of a text file containing real names and ratings, to replace Lichess usernames and ratings in the PGN.
         *     Example: <https://gist.githubusercontent.com/ornicar/6bfa91eb61a2dcae7bcd14cce1b2a4eb/raw/768b9f6cc8a8471d2555e47ba40fb0095e5fba37/gistfile1.txt>
         *      */
        players?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Game IDs separated by commas. Up to 300. */
    requestBody: {
      content: {
        /** @example TJxUmbWK,4OtIh2oh,ILwozzRZ */
        "text/plain": string;
      };
    };
    responses: {
      /** @description The representation of the games. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["GamePgn"];
          "application/x-ndjson": components["schemas"]["GameJson"];
        };
      };
    };
  };
  gamesByUsers: {
    parameters: {
      query?: {
        /** @description Include the already started games at the beginning of the stream. */
        withCurrentGames?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Up to 300 user IDs separated by commas.
     *     Example: `thibault,maia1,maia5`
     *      */
    requestBody: {
      content: {
        "text/plain": string;
      };
    };
    responses: {
      /** @description The stream of the games played between the users. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["GameStream"];
        };
      };
    };
  };
  gamesByIds: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        streamId: string;
      };
      cookie?: never;
    };
    /** @description Up to 500 or 1000 game IDs separated by commas.
     *     Example: `gameId01,gameId02,gameId03`
     *      */
    requestBody: {
      content: {
        "text/plain": string;
      };
    };
    responses: {
      /** @description The stream of the games matching the requested IDs. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["GameStream"];
        };
      };
    };
  };
  gamesByIdsAdd: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        streamId: string;
      };
      cookie?: never;
    };
    /** @description Up to 500 or 1000 game IDs separated by commas.
     *     Example: `gameId04,gameId05,gameId06`
     *      */
    requestBody: {
      content: {
        "text/plain": string;
      };
    };
    responses: {
      /** @description The game IDs have been added to the stream. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  apiAccountPlaying: {
    parameters: {
      query?: {
        /** @description Max number of games to fetch */
        nb?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The ongoing games of the logged in user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            nowPlaying: {
              fullId: string;
              gameId: string;
              fen: string;
              /** @enum {string} */
              color: "white" | "black";
              lastMove: string;
              source: components["schemas"]["GameSource"];
              status?: components["schemas"]["GameStatus"];
              variant: components["schemas"]["Variant"];
              speed: components["schemas"]["Speed"];
              perf: components["schemas"]["PerfType"];
              rated: boolean;
              hasMoved: boolean;
              opponent: {
                id: string;
                username: string;
                rating?: number;
                ratingDiff?: number;
                ai?: number;
              };
              isMyTurn: boolean;
              secondsLeft: number;
              tournamentId?: string;
              swissId?: string;
              /** @enum {string} */
              winner?: "white" | "black";
              ratingDiff?: number;
            }[];
          };
        };
      };
    };
  };
  streamGame: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The stream of the game moves. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["MoveStream"];
        };
      };
    };
  };
  gameImport: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description A single game to import */
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description The PGN. It can contain only one game. Most standard tags are supported. */
          pgn?: string;
        };
      };
    };
    responses: {
      /** @description The game was successfully imported. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /**
             * @description The game ID
             * @example R6iLjwz5
             */
            id?: string;
            /**
             * Format: uri
             * @description The game URL
             */
            url?: string;
          };
        };
      };
    };
  };
  apiImportedGamesUser: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Imported games in PGN format */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["GamePgn"];
        };
      };
    };
  };
  apiExportBookmarks: {
    parameters: {
      query?: {
        /** @description Download games bookmarked since this timestamp. Defaults to account creation date. */
        since?: number;
        /** @description Download games bookmarked until this timestamp. Defaults to now. */
        until?: number;
        /** @description How many bookmarked games to download. Leave empty to download all bookmarked games. */
        max?: number;
        /** @description Include the PGN moves. */
        moves?: boolean;
        /** @description Include the full PGN within the JSON response, in a `pgn` field. The response type must be set to `application/x-ndjson` by the request `Accept` header. */
        pgnInJson?: boolean;
        /** @description Include the PGN tags. */
        tags?: boolean;
        /** @description Include clock status when available.
         *     Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *     Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *      */
        clocks?: boolean;
        /** @description Include analysis evaluations and comments, when available.
         *     Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         *     Or in an `analysis` JSON field, depending on the response type.
         *      */
        evals?: boolean;
        /** @description Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *      */
        accuracy?: boolean;
        /** @description Include the opening name.
         *     Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *      */
        opening?: boolean;
        /** @description Plies which mark the beginning of the middlegame and endgame.
         *     Only available in JSON
         *      */
        division?: boolean;
        /** @description Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         *     Example: `5... g4? { (-0.98  0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *      */
        literate?: boolean;
        /** @description Include the FEN notation of the last position of the game.
         *     The response type must be set to `application/x-ndjson` by the request `Accept` header.
         *      */
        lastFen?: boolean;
        /** @description Sort order of the bookmarks. */
        sort?: "dateAsc" | "dateDesc";
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The bookmarked games of the user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["GamePgn"];
          "application/x-ndjson": components["schemas"]["GameJson"];
        };
      };
    };
  };
  tvChannels: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of games being played for each speed and variant. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            bot: components["schemas"]["TvGame"];
            blitz: components["schemas"]["TvGame"];
            racingKings: components["schemas"]["TvGame"];
            ultraBullet: components["schemas"]["TvGame"];
            bullet: components["schemas"]["TvGame"];
            classical: components["schemas"]["TvGame"];
            threeCheck: components["schemas"]["TvGame"];
            antichess: components["schemas"]["TvGame"];
            computer: components["schemas"]["TvGame"];
            horde: components["schemas"]["TvGame"];
            rapid: components["schemas"]["TvGame"];
            atomic: components["schemas"]["TvGame"];
            crazyhouse: components["schemas"]["TvGame"];
            chess960: components["schemas"]["TvGame"];
            kingOfTheHill: components["schemas"]["TvGame"];
            best: components["schemas"]["TvGame"];
          };
        };
      };
    };
  };
  tvFeed: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The stream of the current TV game. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["TvFeed"];
        };
      };
    };
  };
  tvChannelFeed: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the channel in camel case. */
        channel: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The stream of the current TV game of a TV channel. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["TvFeed"];
        };
      };
    };
  };
  tvChannelGames: {
    parameters: {
      query?: {
        /** @description Number of games to fetch. */
        nb?: number;
        /** @description Include the PGN moves. */
        moves?: boolean;
        /** @description Include the full PGN within the JSON response, in a `pgn` field. */
        pgnInJson?: boolean;
        /** @description Include the PGN tags. */
        tags?: boolean;
        /** @description Include clock status when available.
         *     Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *     Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *      */
        clocks?: boolean;
        /** @description Include the opening name.
         *     Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *      */
        opening?: boolean;
      };
      header?: never;
      path: {
        /** @description The name of the channel in camel case. */
        channel: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The representation of the games. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["GamePgn"];
          "application/x-ndjson": components["schemas"]["GameJson"];
        };
      };
    };
  };
  apiTournament: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of current tournaments. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ArenaTournaments"];
        };
      };
    };
  };
  apiTournamentPost: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters of the tournament */
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description The tournament name. Leave empty to get a random Grandmaster name */
          name?: string;
          /**
           * @description Clock initial time in minutes
           * @example 2
           * @enum {number}
           */
          clockTime:
            | 0
            | 0.25
            | 0.5
            | 0.75
            | 1
            | 1.5
            | 2
            | 3
            | 4
            | 5
            | 6
            | 7
            | 8
            | 10
            | 15
            | 20
            | 25
            | 30
            | 40
            | 50
            | 60;
          /**
           * @description Clock increment in seconds
           * @example 1
           * @enum {integer}
           */
          clockIncrement:
            | 0
            | 1
            | 2
            | 3
            | 4
            | 5
            | 6
            | 7
            | 10
            | 15
            | 20
            | 25
            | 30
            | 40
            | 50
            | 60;
          /**
           * @description How long the tournament lasts, in minutes
           * @example 60
           * @enum {integer}
           */
          minutes:
            | 20
            | 25
            | 30
            | 35
            | 40
            | 45
            | 50
            | 55
            | 60
            | 70
            | 80
            | 90
            | 100
            | 110
            | 120
            | 150
            | 180
            | 210
            | 240
            | 270
            | 300
            | 330
            | 360
            | 420
            | 480
            | 540
            | 600
            | 720;
          /**
           * @description How long to wait before starting the tournament, from now, in minutes
           * @default 5
           * @enum {integer}
           */
          waitMinutes?: 1 | 2 | 3 | 5 | 10 | 15 | 20 | 30 | 45 | 60;
          /**
           * Format: int64
           * @description Timestamp (in milliseconds) to start the tournament at a given date and time. Overrides the `waitMinutes` setting
           */
          startDate?: number;
          variant?: components["schemas"]["VariantKey"];
          /**
           * @description Games are rated and impact players ratings
           * @default true
           */
          rated?: boolean;
          position?: components["schemas"]["FromPositionFEN"];
          /**
           * @description Whether the players can use berserk. Only allowed if clockIncrement <= clockTime * 2
           * @default true
           */
          berserkable?: boolean;
          /**
           * @description After 2 wins, consecutive wins grant 4 points instead of 2.
           * @default true
           */
          streakable?: boolean;
          /**
           * @description Whether the players can discuss in a chat
           * @default true
           */
          hasChat?: boolean;
          /** @description Anything you want to tell players about the tournament */
          description?: string;
          /** @description Make the tournament private, and restrict access with a password.
           *     You can also [generate user-specific entry codes](https://github.com/lichess-org/api/tree/master/example/tournament-entry-code)
           *     based on this password.
           *      */
          password?: string;
          /** @description Set the ID of a team you lead to create a team battle.
           *     The other teams can be added using the [team battle edit endpoint](#operation/apiTournamentTeamBattlePost).
           *      */
          teamBattleByTeam?: string;
          /** @description Restrict entry to members of a team.
           *     The teamId is the last part of a team URL, e.g. `https://lichess.org/team/coders` has teamId = `coders`.
           *     Leave empty to let everyone join the tournament.
           *     Do not use this to create team battles, use `teamBattleByTeam` instead.
           *      */
          "conditions.teamMember.teamId"?: string;
          /**
           * @description Minimum rating to join. Leave empty to let everyone join the tournament.
           * @enum {integer}
           */
          "conditions.minRating.rating"?:
            | 1000
            | 1100
            | 1200
            | 1300
            | 1400
            | 1500
            | 1600
            | 1700
            | 1800
            | 1900
            | 2000
            | 2100
            | 2200
            | 2300
            | 2400
            | 2500
            | 2600;
          /**
           * @description Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
           * @enum {integer}
           */
          "conditions.maxRating.rating"?:
            | 2200
            | 2100
            | 2000
            | 1900
            | 1800
            | 1700
            | 1600
            | 1500
            | 1400
            | 1300
            | 1200
            | 1100
            | 1000
            | 900
            | 800;
          /**
           * @description Minimum number of rated games required to join.
           * @enum {integer}
           */
          "conditions.nbRatedGame.nb"?:
            | 0
            | 5
            | 10
            | 15
            | 20
            | 30
            | 40
            | 50
            | 75
            | 100
            | 150
            | 200;
          /** @description Predefined list of usernames that are allowed to join, separated by commas.
           *     If this list is non-empty, then usernames absent from this list will be forbidden to join.
           *     Adding `%titled` to the list additionally allows any titled player to join.
           *     Example: `thibault,german11,%titled`
           *      */
          "conditions.allowList"?: string;
          /**
           * @description Whether bots are allowed to join the tournament.
           * @default false
           */
          "conditions.bots"?: boolean;
          /**
           * @description Minium account age in days required to join.
           * @enum {integer}
           */
          "conditions.accountAge"?:
            | 1
            | 3
            | 7
            | 14
            | 30
            | 60
            | 90
            | 180
            | 365
            | 730
            | 1095;
        };
      };
    };
    responses: {
      /** @description The Arena tournament has been successfully created. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ArenaTournamentFull"];
        };
      };
      /** @description The creation of the Arena tournament failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  tournament: {
    parameters: {
      query?: {
        /** @description Specify which page of player standings to view. */
        page?: number;
      };
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The information of the Arena tournament. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ArenaTournamentFull"];
        };
      };
    };
  };
  apiTournamentUpdate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    /** @description Parameters of the tournament */
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description The tournament name. Leave empty to get a random Grandmaster name */
          name?: string;
          /**
           * @description Clock initial time in minutes
           * @example 2
           * @enum {number}
           */
          clockTime:
            | 0
            | 0.25
            | 0.5
            | 0.75
            | 1
            | 1.5
            | 2
            | 3
            | 4
            | 5
            | 6
            | 7
            | 8
            | 10
            | 15
            | 20
            | 25
            | 30
            | 40
            | 50
            | 60;
          /**
           * @description Clock increment in seconds
           * @example 1
           * @enum {integer}
           */
          clockIncrement:
            | 0
            | 1
            | 2
            | 3
            | 4
            | 5
            | 6
            | 7
            | 10
            | 15
            | 20
            | 25
            | 30
            | 40
            | 50
            | 60;
          /**
           * @description How long the tournament lasts, in minutes
           * @example 60
           * @enum {integer}
           */
          minutes:
            | 20
            | 25
            | 30
            | 35
            | 40
            | 45
            | 50
            | 55
            | 60
            | 70
            | 80
            | 90
            | 100
            | 110
            | 120
            | 150
            | 180
            | 210
            | 240
            | 270
            | 300
            | 330
            | 360
            | 420
            | 480
            | 540
            | 600
            | 720;
          /**
           * @description How long to wait before starting the tournament, from now, in minutes
           * @default 5
           * @enum {integer}
           */
          waitMinutes?: 1 | 2 | 3 | 5 | 10 | 15 | 20 | 30 | 45 | 60;
          /**
           * Format: int64
           * @description Timestamp (in milliseconds) to start the tournament at a given date and time. Overrides the `waitMinutes` setting
           */
          startDate?: number;
          variant?: components["schemas"]["VariantKey"];
          /**
           * @description Games are rated and impact players ratings
           * @default true
           */
          rated?: boolean;
          position?: components["schemas"]["FromPositionFEN"];
          /**
           * @description Whether the players can use berserk. Only allowed if clockIncrement <= clockTime * 2
           * @default true
           */
          berserkable?: boolean;
          /**
           * @description After 2 wins, consecutive wins grant 4 points instead of 2.
           * @default true
           */
          streakable?: boolean;
          /**
           * @description Whether the players can discuss in a chat
           * @default true
           */
          hasChat?: boolean;
          /** @description Anything you want to tell players about the tournament */
          description?: string;
          /** @description Make the tournament private, and restrict access with a password */
          password?: string;
          /**
           * @description Minimum rating to join. Leave empty to let everyone join the tournament.
           * @enum {integer}
           */
          "conditions.minRating.rating"?:
            | 1000
            | 1100
            | 1200
            | 1300
            | 1400
            | 1500
            | 1600
            | 1700
            | 1800
            | 1900
            | 2000
            | 2100
            | 2200
            | 2300
            | 2400
            | 2500
            | 2600;
          /**
           * @description Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
           * @enum {integer}
           */
          "conditions.maxRating.rating"?:
            | 2200
            | 2100
            | 2000
            | 1900
            | 1800
            | 1700
            | 1600
            | 1500
            | 1400
            | 1300
            | 1200
            | 1100
            | 1000
            | 900
            | 800;
          /**
           * @description Minimum number of rated games required to join.
           * @enum {integer}
           */
          "conditions.nbRatedGame.nb"?:
            | 0
            | 5
            | 10
            | 15
            | 20
            | 30
            | 40
            | 50
            | 75
            | 100
            | 150
            | 200;
          /** @description Predefined list of usernames that are allowed to join, separated by commas.
           *     If this list is non-empty, then usernames absent from this list will be forbidden to join.
           *     Adding `%titled` to the list additionally allows any titled player to join.
           *     Example: `thibault,german11,%titled`
           *      */
          "conditions.allowList"?: string;
          /**
           * @description Whether bots are allowed to join the tournament.
           * @default false
           */
          "conditions.bots"?: boolean;
          /**
           * @description Minium account age in days required to join.
           * @enum {integer}
           */
          "conditions.accountAge"?:
            | 1
            | 3
            | 7
            | 14
            | 30
            | 60
            | 90
            | 180
            | 365
            | 730
            | 1095;
        };
      };
    };
    responses: {
      /** @description The Arena tournament was successfully updated. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ArenaTournamentFull"];
        };
      };
      /** @description The update of the Arena tournament failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  apiTournamentJoin: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    /** @description You may need these depending on the tournament to join */
    requestBody?: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description The tournament password, if one is required.
           *     Can also be a [user-specific entry code](https://github.com/lichess-org/api/tree/master/example/tournament-entry-code)
           *     generated and shared by the organizer.
           *      */
          password?: string;
          /** @description The team to join the tournament with, for team battle tournaments */
          team?: string;
          /**
           * @description If the tournament is started, attempt to pair the user,
           *     even if they are not connected to the tournament page.
           *     This expires after one minute, to avoid pairing a user who is long gone.
           *     You may call "join" again to extend the waiting.
           *
           * @default false
           */
          pairMeAsap?: boolean;
        };
      };
    };
    responses: {
      /** @description The tournament was successfully joined. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description Joining the tournament failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  apiTournamentWithdraw: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The tournament was successfully paused or left. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description Pausing/leaving the tournament failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  apiTournamentTerminate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The tournament was successfully terminated. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description Terminating the tournament failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  apiTournamentTeamBattlePost: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The tournament ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description All team IDs of the team battle, separated by commas.
           *     Make sure to always send the full list.
           *     Teams that are not in the list will be removed from the team battle.
           *     Example: `coders,zhigalko_sergei-fan-club,hhSwTKZv`
           *      */
          teams: string;
          /** @description Number team leaders per team. */
          nbLeaders: number;
        };
      };
    };
    responses: {
      /** @description The team battle tournament was successfully updated. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ArenaTournamentFull"];
        };
      };
      /** @description The update of the team battle tournament failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  gamesByTournament: {
    parameters: {
      query?: {
        /** @description Only games of a particular player. Leave empty to fetch games of all players. */
        player?: string;
        /** @description Include the PGN moves. */
        moves?: boolean;
        /** @description Include the full PGN within the JSON response, in a `pgn` field. */
        pgnInJson?: boolean;
        /** @description Include the PGN tags. */
        tags?: boolean;
        /** @description Include clock status when available.
         *     Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *     Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *      */
        clocks?: boolean;
        /** @description Include analysis evaluations and comments, when available.
         *     Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         *     Or in an `analysis` JSON field, depending on the response type.
         *      */
        evals?: boolean;
        /** @description Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *      */
        accuracy?: boolean;
        /** @description Include the opening name.
         *     Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *      */
        opening?: boolean;
        /** @description Plies which mark the beginning of the middlegame and endgame.
         *     Only available in JSON
         *      */
        division?: boolean;
      };
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of games of an Arena tournament. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["GamePgn"];
          "application/x-ndjson": components["schemas"]["GameJson"];
        };
      };
    };
  };
  resultsByTournament: {
    parameters: {
      query?: {
        /** @description Max number of players to fetch */
        nb?: number;
        /** @description Add a `sheet` field to the player document.
         *     It's an expensive server computation that slows down the stream.
         *      */
        sheet?: boolean;
      };
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The results of the Arena tournament. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": {
            rank: number;
            score: number;
            rating: number;
            username: string;
            performance: number;
            title?: components["schemas"]["Title"];
            team: string;
            flair?: components["schemas"]["Flair"];
            sheet?: components["schemas"]["ArenaSheet"];
          };
        };
      };
    };
  };
  teamsByTournament: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of teams of a team battle tournament, with their respective top players. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            id: string;
            teams: {
              rank: number;
              id: string;
              score: number;
              players: {
                user: components["schemas"]["LightUser"];
                score?: number;
              }[];
            }[];
          };
        };
      };
    };
  };
  apiUserNameTournamentCreated: {
    parameters: {
      query?: {
        /** @description Max number of tournaments to fetch */
        nb?: number;
        /** @description Include tournaments in the given status: "Created" (10), "Started" (20), "Finished" (30)
         *     You can add this parameter more than once to include tournaments in different statuses.
         *     Example: `?status=10&status=20`
         *      */
        status?: 10 | 20 | 30;
      };
      header?: never;
      path: {
        /** @description The user whose created tournaments to fetch */
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of tournaments created by the user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["ArenaTournament"];
        };
      };
    };
  };
  apiUserNameTournamentPlayed: {
    parameters: {
      query?: {
        /** @description Max number of tournaments to fetch */
        nb?: number;
        /** @description Include the player performance rating in the response, at some cost for the server.
         *      */
        performance?: boolean;
      };
      header?: never;
      path: {
        /** @description The user whose played tournaments to fetch */
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of tournaments played by the user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["ArenaTournamentPlayed"];
        };
      };
    };
  };
  apiSwissNew: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the team */
        teamId: string;
      };
      cookie?: never;
    };
    /** @description Parameters of the tournament */
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description The tournament name. Leave empty to get a random Grandmaster name */
          name?: string;
          /**
           * @description Clock initial time in seconds
           * @example 300
           * @enum {number}
           */
          "clock.limit":
            | 0
            | 15
            | 30
            | 45
            | 60
            | 90
            | 120
            | 180
            | 240
            | 300
            | 360
            | 420
            | 480
            | 600
            | 900
            | 1200
            | 1500
            | 1800
            | 2400
            | 3000
            | 3600
            | 4200
            | 4800
            | 5400
            | 6000
            | 6600
            | 7200
            | 7800
            | 8400
            | 9000
            | 9600
            | 10200
            | 10800;
          /**
           * @description Clock increment in seconds
           * @example 1
           */
          "clock.increment": number;
          /** @description Maximum number of rounds to play */
          nbRounds: number;
          /**
           * Format: int64
           * @description Timestamp in milliseconds to start the tournament at a given date and time. By default, it starts 10 minutes after creation.
           */
          startsAt?: number;
          /**
           * @description How long to wait between each round, in seconds.
           *     Set to 99999999 to manually schedule each round from the tournament UI.
           *     If empty or -1, a sensible value is picked automatically.
           *
           * @enum {integer}
           */
          roundInterval?:
            | -1
            | 5
            | 10
            | 20
            | 30
            | 45
            | 60
            | 120
            | 180
            | 300
            | 600
            | 900
            | 1200
            | 1800
            | 2700
            | 3600
            | 86400
            | 172800
            | 604800
            | 99999999;
          variant?: components["schemas"]["VariantKey"];
          position?: components["schemas"]["SwissFromPositionFEN"];
          /** @description Anything you want to tell players about the tournament */
          description?: string;
          /**
           * @description Games are rated and impact players ratings
           * @default true
           */
          rated?: boolean;
          /** @description Make the tournament private and restrict access with a password. */
          password?: string;
          /** @description Usernames of players that must not play together.
           *     Two usernames per line, separated by a space.
           *      */
          forbiddenPairings?: string;
          /** @description Manual pairings for the next round.
           *     Two usernames per line, separated by a space. Example:
           *     ```
           *     PlayerA PlayerB
           *     PlayerC PlayerD
           *     ```
           *     To give a bye (1 point) to a player instead of a pairing, add a line like so:
           *     ```
           *     PlayerE 1
           *     ```
           *     Missing players will be considered absent and get zero points.
           *      */
          manualPairings?: string;
          /**
           * @description Who can read and write in the chat.
           *     - 0  = No-one
           *     - 10 = Only team leaders
           *     - 20 = Only team members
           *     - 30 = All Lichess players
           *
           * @default 20
           */
          chatFor?: number;
          /**
           * @description Minimum rating to join. Leave empty to let everyone join the tournament.
           * @enum {integer}
           */
          "conditions.minRating.rating"?:
            | 1000
            | 1100
            | 1200
            | 1300
            | 1400
            | 1500
            | 1600
            | 1700
            | 1800
            | 1900
            | 2000
            | 2100
            | 2200
            | 2300
            | 2400
            | 2500
            | 2600;
          /**
           * @description Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
           * @enum {integer}
           */
          "conditions.maxRating.rating"?:
            | 2200
            | 2100
            | 2000
            | 1900
            | 1800
            | 1700
            | 1600
            | 1500
            | 1400
            | 1300
            | 1200
            | 1100
            | 1000
            | 900
            | 800;
          /** @description Minimum number of rated games required to join. */
          "conditions.nbRatedGame.nb"?: number;
          /**
           * @description Only let players join if they have played their last swiss game.
           *     If they failed to show up in a recent swiss event, they won't be able to enter yours.
           *     This results in a better swiss experience for the players who actually show up.
           *
           * @default false
           */
          "conditions.playYourGames"?: boolean;
          /** @description Predefined list of usernames that are allowed to join, separated by commas.
           *     If this list is non-empty, then usernames absent from this list will be forbidden to join.
           *     Adding `%titled` to the list additionally allows any titled player to join.
           *     Example: `thibault,german11,%titled`
           *      */
          "conditions.allowList"?: string;
        };
      };
    };
    responses: {
      /** @description The Swiss tournament was successfully created. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["SwissTournament"];
        };
      };
      /** @description The creation of the Swiss tournament failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  swiss: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The Swiss tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The information of the Swiss tournament. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["SwissTournament"];
        };
      };
    };
  };
  apiSwissUpdate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    /** @description Parameters of the tournament */
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description The tournament name. Leave empty to get a random Grandmaster name */
          name?: string;
          /**
           * @description Clock initial time in seconds
           * @example 300
           * @enum {number}
           */
          "clock.limit":
            | 0
            | 15
            | 30
            | 45
            | 60
            | 90
            | 120
            | 180
            | 240
            | 300
            | 360
            | 420
            | 480
            | 600
            | 900
            | 1200
            | 1500
            | 1800
            | 2400
            | 3000
            | 3600
            | 4200
            | 4800
            | 5400
            | 6000
            | 6600
            | 7200
            | 7800
            | 8400
            | 9000
            | 9600
            | 10200
            | 10800;
          /**
           * @description Clock increment in seconds
           * @example 1
           */
          "clock.increment": number;
          /** @description Maximum number of rounds to play */
          nbRounds: number;
          /**
           * Format: int64
           * @description Timestamp in milliseconds to start the tournament at a given date and time. By default, it starts 10 minutes after creation.
           */
          startsAt?: number;
          /**
           * @description How long to wait between each round, in seconds.
           *     Set to 99999999 to manually schedule each round from the tournament UI, or [with the API](#tag/Swiss-tournaments/operation/apiSwissScheduleNextRound).
           *     If empty or -1, a sensible value is picked automatically.
           *
           * @enum {integer}
           */
          roundInterval?:
            | -1
            | 5
            | 10
            | 20
            | 30
            | 45
            | 60
            | 120
            | 180
            | 300
            | 600
            | 900
            | 1200
            | 1800
            | 2700
            | 3600
            | 86400
            | 172800
            | 604800
            | 99999999;
          variant?: components["schemas"]["VariantKey"];
          position?: components["schemas"]["SwissFromPositionFEN"];
          /** @description Anything you want to tell players about the tournament */
          description?: string;
          /**
           * @description Games are rated and impact players ratings
           * @default true
           */
          rated?: boolean;
          /** @description Make the tournament private and restrict access with a password. */
          password?: string;
          /** @description Usernames of players that must not play together.
           *     Two usernames per line, separated by a space.
           *      */
          forbiddenPairings?: string;
          /** @description Manual pairings for the next round.
           *     Two usernames per line, separated by a space.
           *     Present players without a valid pairing will be given a bye, which is worth 1 point.
           *     Forfeited players will get 0 points.
           *      */
          manualPairings?: string;
          /**
           * @description Who can read and write in the chat.
           *     - 0  = No-one
           *     - 10 = Only team leaders
           *     - 20 = Only team members
           *     - 30 = All Lichess players
           *
           * @default 20
           */
          chatFor?: number;
          /**
           * @description Minimum rating to join. Leave empty to let everyone join the tournament.
           * @enum {integer}
           */
          "conditions.minRating.rating"?:
            | 1000
            | 1100
            | 1200
            | 1300
            | 1400
            | 1500
            | 1600
            | 1700
            | 1800
            | 1900
            | 2000
            | 2100
            | 2200
            | 2300
            | 2400
            | 2500
            | 2600;
          /**
           * @description Maximum rating to join. Based on best rating reached in the last 7 days. Leave empty to let everyone join the tournament.
           * @enum {integer}
           */
          "conditions.maxRating.rating"?:
            | 2200
            | 2100
            | 2000
            | 1900
            | 1800
            | 1700
            | 1600
            | 1500
            | 1400
            | 1300
            | 1200
            | 1100
            | 1000
            | 900
            | 800;
          /** @description Minimum number of rated games required to join. */
          "conditions.nbRatedGame.nb"?: number;
          /**
           * @description Only let players join if they have played their last swiss game.
           *     If they failed to show up in a recent swiss event, they won't be able to enter yours.
           *     This results in a better swiss experience for the players who actually show up.
           *
           * @default false
           */
          "conditions.playYourGames"?: boolean;
          /** @description Predefined list of usernames that are allowed to join, separated by commas.
           *     If this list is non-empty, then usernames absent from this list will be forbidden to join.
           *     Adding `%titled` to the list additionally allows any titled player to join.
           *     Example: `thibault,german11,%titled`
           *      */
          "conditions.allowList"?: string;
        };
      };
    };
    responses: {
      /** @description The Swiss tournament was successfully updated. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["SwissTournament"];
        };
      };
      /** @description Updating the swiss failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description This user cannot update this Swiss. */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["SwissUnauthorisedEdit"];
        };
      };
    };
  };
  apiSwissScheduleNextRound: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    /** @description Parameters of the tournament */
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /**
           * Format: int64
           * @description Timestamp in milliseconds to start the next round at a given date and time.
           */
          date?: number;
        };
      };
    };
    responses: {
      /** @description The Swiss tournament was successfully updated. */
      204: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Updating the swiss failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description This user cannot update this Swiss. */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["SwissUnauthorisedEdit"];
        };
      };
    };
  };
  apiSwissJoin: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    /** @description You may need these depending on the tournament to join */
    requestBody?: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description The tournament password, if one is required */
          password?: string;
        };
      };
    };
    responses: {
      /** @description The tournament was successfully joined. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description Joining the tournament failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  apiSwissWithdraw: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The tournament was successfully paused or left. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  apiSwissTerminate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The Swiss tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The Swiss tournament was successfully terminated. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description Terminating the Swiss tournament failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  swissTrf: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The TRF representation of a Swiss tournament. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "text/plain": string;
        };
      };
    };
  };
  gamesBySwiss: {
    parameters: {
      query?: {
        /** @description Only the games played by a given player */
        player?: string;
        /** @description Include the PGN moves. */
        moves?: boolean;
        /** @description Include the full PGN within the JSON response, in a `pgn` field. */
        pgnInJson?: boolean;
        /** @description Include the PGN tags. */
        tags?: boolean;
        /** @description Include clock status when available.
         *     Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *     Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *      */
        clocks?: boolean;
        /** @description Include analysis evaluations and comments, when available.
         *     Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         *     Or in an `analysis` JSON field, depending on the response type.
         *      */
        evals?: boolean;
        /** @description Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *      */
        accuracy?: boolean;
        /** @description Include the opening name.
         *     Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *      */
        opening?: boolean;
        /** @description Plies which mark the beginning of the middlegame and endgame.
         *     Only available in JSON
         *      */
        division?: boolean;
      };
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of games of a Swiss tournament. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["GamePgn"];
          "application/x-ndjson": components["schemas"]["GameJson"];
        };
      };
    };
  };
  resultsBySwiss: {
    parameters: {
      query?: {
        /** @description Max number of players to fetch */
        nb?: number;
      };
      header?: never;
      path: {
        /** @description The tournament ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The results of a Swiss tournament. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": {
            absent?: boolean;
            rank: number;
            points: number;
            tieBreak: number;
            rating: number;
            username: string;
            title?: components["schemas"]["Title"];
            performance: number;
          };
        };
      };
    };
  };
  apiTeamSwiss: {
    parameters: {
      query?: {
        /** @description How many tournaments to download. */
        max?: number;
        /** @description [Filter] Only swiss tournaments in this current state.
         *      */
        status?: components["schemas"]["SwissStatus"] & unknown;
        /** @description [Filter] Only swiss tournaments created by a given user.
         *      */
        createdBy?: string;
        /** @description [Filter] Only swiss tournaments with a given name.
         *      */
        name?: string;
      };
      header?: never;
      path: {
        /** @example coders */
        teamId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of Swiss tournaments of a team. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["SwissTournament"];
        };
      };
    };
  };
  studyChapterPgn: {
    parameters: {
      query?: {
        /** @description Include clock comments in the PGN moves, when available.
         *     Example: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *      */
        clocks?: boolean;
        /** @description Include analysis and annotator comments in the PGN moves, when available.
         *     Example: `12. Bxf6 { [%eval 0.23] } a3 { White is in a pickle. }`
         *      */
        comments?: boolean;
        /** @description Include non-mainline moves, when available.
         *     Example: `4. d4 Bb4+ (4... Nc6 5. Nf3 Bb4+ 6. Bd2 (6. Nbd2 O-O 7. O-O) 6... Bd6) 5. Nd2`
         *      */
        variations?: boolean;
        /** @description Add a `Source` PGN tag with the study chapter URL.
         *     Example: `[Source "https://lichess.org/study/4NBHImfM/1Tk4IyTz"]`
         *      */
        source?: boolean;
        /** @description Add a `Orientation` PGN tag with the chapter predefined orientation.
         *     Example: `[Orientation "white"]`
         *      */
        orientation?: boolean;
      };
      header?: never;
      path: {
        /** @description The study ID */
        studyId: string;
        /** @description The chapter ID */
        chapterId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The chapter of the study. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["StudyPgn"];
        };
      };
    };
  };
  studyAllChaptersPgn: {
    parameters: {
      query?: {
        /** @description Include clock comments in the PGN moves, when available.
         *     Example: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *      */
        clocks?: boolean;
        /** @description Include analysis and annotator comments in the PGN moves, when available.
         *     Example: `12. Bxf6 { [%eval 0.23] } a3 { White is in a pickle. }`
         *      */
        comments?: boolean;
        /** @description Include non-mainline moves, when available.
         *     Example: `4. d4 Bb4+ (4... Nc6 5. Nf3 Bb4+ 6. Bd2 (6. Nbd2 O-O 7. O-O) 6... Bd6) 5. Nd2`
         *      */
        variations?: boolean;
        /** @description Add a `Source` PGN tag with the study chapter URL.
         *     Example: `[Source "https://lichess.org/study/4NBHImfM/1Tk4IyTz"]`
         *      */
        source?: boolean;
        /** @description Add a `Orientation` PGN tag with the chapter predefined orientation.
         *     Example: `[Orientation "white"]`
         *      */
        orientation?: boolean;
      };
      header?: never;
      path: {
        /** @description The study ID */
        studyId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The PGN representation of the study. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          "Last-Modified"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["StudyPgn"];
        };
      };
    };
  };
  studyAllChaptersHead: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The study ID */
        studyId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The study headers. */
      204: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          "Last-Modified"?: string;
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  apiStudyImportPGN: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the study */
        studyId: string;
      };
      cookie?: never;
    };
    /** @description Parameters of the import */
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description PGN to import. Can contain multiple games separated by 2 or more newlines.
           *      */
          pgn: string;
          /** @description Name of the new chapter.
           *     If not specified, or if multiple chapters are created, the names will be inferred from the PGN tags.
           *      */
          name?: string;
          /**
           * @description Default board orientation.
           * @default white
           * @enum {string}
           */
          orientation?: "white" | "black";
          variant?: components["schemas"]["VariantKey"];
        };
      };
    };
    responses: {
      /** @description The chapters that were created. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["StudyImportPgnChapters"];
        };
      };
      /** @description The creation of the chapter(s) failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  studyExportAllPgn: {
    parameters: {
      query?: {
        /** @description Include clock comments in the PGN moves, when available.
         *     Example: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *      */
        clocks?: boolean;
        /** @description Include analysis and annotator comments in the PGN moves, when available.
         *     Example: `12. Bxf6 { [%eval 0.23] } a3 { White is in a pickle. }`
         *      */
        comments?: boolean;
        /** @description Include non-mainline moves, when available.
         *     Example: `4. d4 Bb4+ (4... Nc6 5. Nf3 Bb4+ 6. Bd2 (6. Nbd2 O-O 7. O-O) 6... Bd6) 5. Nd2`
         *      */
        variations?: boolean;
        /** @description Add a `Source` PGN tag with the study chapter URL.
         *     Example: `[Source "https://lichess.org/study/4NBHImfM/1Tk4IyTz"]`
         *      */
        source?: boolean;
        /** @description Add a `Orientation` PGN tag with the chapter predefined orientation.
         *     Example: `[Orientation "white"]`
         *      */
        orientation?: boolean;
      };
      header?: never;
      path: {
        /** @description The user whose studies we export */
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The studies of the user. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["StudyPgn"];
        };
      };
    };
  };
  studyListMetadata: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The user whose studies we list */
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of studies. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["StudyMetadata"];
        };
      };
    };
  };
  apiStudyStudyIdChapterIdDelete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The study ID */
        studyId: string;
        /** @description The chapter ID */
        chapterId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Chapter successfully deleted */
      204: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  broadcastsOfficial: {
    parameters: {
      query?: {
        /** @description Max number of broadcasts to fetch */
        nb?: number;
        /**
         * @description Convert the "description" field from markdown to HTML
         * @example true
         */
        html?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of official broadcasts. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["BroadcastWithRounds"];
        };
      };
    };
  };
  broadcastsTop: {
    parameters: {
      query?: {
        /** @description Which page to fetch. Only page 1 has "active" broadcasts. */
        page?: number;
        /**
         * @description Convert the "description" field from markdown to HTML
         * @example true
         */
        html?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Paginated top broadcast previews. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BroadcastTop"];
        };
      };
    };
  };
  broadcastsByUser: {
    parameters: {
      query?: {
        page?: number;
        /**
         * @description Convert the "description" field from markdown to HTML
         * @example true
         */
        html?: boolean;
      };
      header?: never;
      path: {
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A paginated list of the broadcasts created by a user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** @example 4 */
            currentPage: number;
            /** @example 15 */
            maxPerPage: number;
            currentPageResults: components["schemas"]["BroadcastByUser"][];
            /** @example 205194 */
            nbResults: number;
            /** @example 3 */
            previousPage: number | null;
            /** @example 5 */
            nextPage: number | null;
            /** @example 13680 */
            nbPages: number;
          };
        };
      };
    };
  };
  broadcastTourCreate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["BroadcastForm"];
      };
    };
    responses: {
      /** @description The broadcast tournament was successfully created. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BroadcastWithRounds"];
        };
      };
      /** @description The creation of the broadcast tournament failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  broadcastTourGet: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The broadcast tournament ID */
        broadcastTournamentId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The information about the broadcast tournament. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BroadcastWithRounds"];
        };
      };
    };
  };
  broadcastPlayersGet: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The broadcast tournament ID */
        broadcastTournamentId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The broadcast players */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BroadcastPlayerEntry"][];
        };
      };
    };
  };
  broadcastTourUpdate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The broadcast ID */
        broadcastTournamentId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["BroadcastForm"];
      };
    };
    responses: {
      /** @description The broadcast tournament was successfully edited. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The broadcast tournament update failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  broadcastRoundCreate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The broadcast tournament ID */
        broadcastTournamentId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["BroadcastRoundForm"];
      };
    };
    responses: {
      /** @description The broadcast round was successfully created. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BroadcastRoundNew"];
        };
      };
      /** @description The creation of the broadcast failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  broadcastRoundGet: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The broadcast tournament slug. Only used for SEO, the slug can be safely replaced by `-`. Only the `broadcastRoundId` is actually used. */
        broadcastTournamentSlug: string;
        /** @description The broadcast round slug. Only used for SEO, the slug can be safely replaced by `-`. Only the `broadcastRoundId` is actually used. */
        broadcastRoundSlug: string;
        /** @description The broadcast Round ID */
        broadcastRoundId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The information about the broadcast round. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BroadcastRound"];
        };
      };
    };
  };
  broadcastRoundUpdate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The broadcast round ID */
        broadcastRoundId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": components["schemas"]["BroadcastRoundForm"];
      };
    };
    responses: {
      /** @description The broadcast round was successfully edited. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The broadcast round update failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  broadcastRoundReset: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The broadcast round ID */
        broadcastRoundId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The broadcast round was successfully reset. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  broadcastPush: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The broadcast round ID */
        broadcastRoundId: string;
      };
      cookie?: never;
    };
    /** @description The PGN. It can contain up to 64 games, separated by a double new line. */
    requestBody: {
      content: {
        "text/plain": string;
      };
    };
    responses: {
      /** @description The broadcast was successfully updated. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BroadcastPgnPush"];
        };
      };
      /** @description There was a problem with the pushed PGN. */
      400: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            error?: string;
          };
        };
      };
    };
  };
  broadcastStreamRoundPgn: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The broadcast round ID */
        broadcastRoundId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The PGN representation of the tournament games, then the PGNs of games as they are updated. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["StudyPgn"];
        };
      };
    };
  };
  broadcastRoundPgn: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The round ID */
        broadcastRoundId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The PGN representation of the round. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["StudyPgn"];
        };
      };
    };
  };
  broadcastAllRoundsPgn: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The broadcast tournament ID */
        broadcastTournamentId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The PGN representation of the broadcast. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["StudyPgn"];
        };
      };
    };
  };
  broadcastMyRoundsGet: {
    parameters: {
      query?: {
        /** @description How many rounds to get */
        nb?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The broadcast rounds with their tournament and a `study.writeable` flag. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["BroadcastMyRound"];
        };
      };
    };
  };
  fidePlayerGet: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The FIDE player ID. */
        playerId: number;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The information about the FIDE player. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["FIDEPlayer"];
        };
      };
    };
  };
  fidePlayerSearch: {
    parameters: {
      query: {
        /** @description The search query. */
        q: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of FIDE players. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["FIDEPlayer"][];
        };
      };
    };
  };
  apiSimul: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of simuls. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            pending?: components["schemas"]["Simul"][];
            created?: components["schemas"]["Simul"][];
            started?: components["schemas"]["Simul"][];
            finished?: components["schemas"]["Simul"][];
          };
        };
      };
    };
  };
  teamShow: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        teamId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The information about the team. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Team"];
        };
      };
    };
  };
  teamAll: {
    parameters: {
      query?: {
        page?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A paginated list of the most popular teams. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["TeamPaginatorJson"];
        };
      };
    };
  };
  teamOfUsername: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of teams the user is a member of. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Team"][];
        };
      };
    };
  };
  teamSearch: {
    parameters: {
      query?: {
        text?: string;
        page?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The paginated list of teams. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["TeamPaginatorJson"];
        };
      };
    };
  };
  teamIdUsers: {
    parameters: {
      query?: {
        /** @description Full user documents with performance ratings.
         *     This limits the response to 1,000 users.
         *      */
        full?: boolean;
      };
      header?: never;
      path: {
        teamId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of users in the team. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": {
            /**
             * Format: int64
             * @example 1716930043067
             */
            joinedTeamAt?: number;
            /** @example chess-network */
            id: string;
            /** @example Chess-Network */
            name: string;
            title?: components["schemas"]["Title"];
            /** @example true */
            patron?: boolean;
          };
        };
      };
    };
  };
  apiTeamArena: {
    parameters: {
      query?: {
        /** @description How many tournaments to download. */
        max?: number;
        /** @description [Filter] Only arena tournaments in this current state.
         *      */
        status?: components["schemas"]["ArenaStatusName"] & unknown;
        /** @description [Filter] Only arena tournaments created by a given user.
         *      */
        createdBy?: string;
        /** @description [Filter] Only arena tournaments with a given name.
         *      */
        name?: string;
      };
      header?: never;
      path: {
        /** @description ID of the team */
        teamId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of Arena tournaments of a team. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["ArenaTournament"];
        };
      };
    };
  };
  teamIdJoin: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        teamId: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description Required if team manually reviews admission requests. */
          message?: string;
          /** @description Optional password, if the team requires one. */
          password?: string;
        };
      };
    };
    responses: {
      /** @description The request to join a team was successfully sent. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  teamIdQuit: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        teamId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The logged in user has successfully left the team. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  teamRequests: {
    parameters: {
      query?: {
        /** @description Get the declined join requests */
        declined?: boolean;
      };
      header?: never;
      path: {
        teamId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of pending join requests on your team */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["TeamRequestWithUser"][];
        };
      };
    };
  };
  teamRequestAccept: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        teamId: string;
        userId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The member has been added to the team. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  teamRequestDecline: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        teamId: string;
        userId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The join request has been declined and is no longer pending. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  teamIdKickUserId: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        teamId: string;
        userId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The member has been kicked from the team. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  teamIdPmAll: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        teamId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description The message to send to all your team members. */
          message?: string;
        };
      };
    };
    responses: {
      /** @description The message has successfully been sent to all team members. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The sending of message to all team members has failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  streamerLive: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of live streamers and their respective information. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": (components["schemas"]["LightUser"] & {
            stream?: {
              /** @enum {string} */
              service?: "twitch" | "youTube";
              /** @description The stream title */
              status?: string;
              lang?: string;
            };
            streamer?: {
              name?: string;
              headline?: string;
              description?: string;
              /** Format: uri */
              twitch?: string;
              /** Format: uri */
              youTube?: string;
              /** Format: uri */
              image?: string;
            };
          })[];
        };
      };
    };
  };
  apiCrosstable: {
    parameters: {
      query?: {
        /** @description Whether to get the current match data, if any */
        matchup?: boolean;
      };
      header?: never;
      path: {
        user1: string;
        user2: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The crosstable of the two users. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Crosstable"];
        };
      };
    };
  };
  apiPlayerAutocomplete: {
    parameters: {
      query: {
        /** @description The beginning of a username */
        term: string;
        /** @description - `false` returns an array of usernames
         *     - `true` returns an object with matching users
         *      */
        object?: boolean;
        /** @description Returns followed players matching `term` if any, else returns other players.
         *     Requires [OAuth](#tag/OAuth).
         *      */
        friend?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description An array of players which usernames start with the provided term. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json":
            | string[]
            | {
                result?: components["schemas"]["LightUserOnline"][];
              };
        };
      };
    };
  };
  readNote: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of notes you have added for this user */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["UserNote"][];
        };
      };
    };
  };
  writeNote: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        username: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description The contents of the note */
          text: string;
        };
      };
    };
    responses: {
      /** @description The note was successfully added. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  apiUserFollowing: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of users followed by a user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["UserExtended"];
        };
      };
    };
  };
  followUser: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The player was successfully added. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  unfollowUser: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The player was successfully removed. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  blockUser: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The player was successfully added. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  unblockUser: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        username: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The player was successfully removed. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  apiStreamEvent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The stream of events reaching the logged in user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson":
            | components["schemas"]["GameStartEvent"]
            | components["schemas"]["GameFinishEvent"]
            | components["schemas"]["ChallengeEvent"]
            | components["schemas"]["ChallengeCanceledEvent"]
            | components["schemas"]["ChallengeDeclinedEvent"];
        };
      };
    };
  };
  apiBoardSeek: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters of the seek */
    requestBody?: {
      content: {
        "application/x-www-form-urlencoded": {
          /**
           * @description Whether the game is rated and impacts players ratings.
           * @default false
           * @example true
           */
          rated?: boolean;
          variant?: components["schemas"]["VariantKey"];
          /** @description The rating range of potential opponents. Better left empty.
           *     Example: 1500-1800
           *      */
          ratingRange?: string;
        } & (
          | {
              /**
               * @description Clock initial time in minutes. Required for real-time seeks.
               * @example 15
               */
              time: number;
              /**
               * @description Clock increment in seconds. Required for real-time seeks.
               * @example 15
               */
              increment: number;
              /**
               * @description The color to play. Better left empty to automatically get 50% white.
               * @default random
               * @enum {string}
               */
              color?: "random" | "white" | "black";
            }
          | {
              /**
               * @description Days per turn. Required for correspondence seeks.
               * @enum {integer}
               */
              days: 1 | 2 | 3 | 5 | 7 | 10 | 14;
            }
        );
      };
    };
    responses: {
      /** @description The seek was successfully created. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            id: string;
          };
          "application/x-ndjson": unknown;
        };
      };
      /** @description The creation of the seek failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  boardGameStream: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The stream of the game. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson":
            | components["schemas"]["GameFullEvent"]
            | components["schemas"]["GameStateEvent"]
            | components["schemas"]["ChatLineEvent"]
            | components["schemas"]["OpponentGone"];
        };
      };
      /** @description The game was not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["NotFound"];
        };
      };
    };
  };
  boardGameMove: {
    parameters: {
      query?: {
        /** @description Whether to offer (or agree to) a draw */
        offeringDraw?: boolean;
      };
      header?: never;
      path: {
        gameId: string;
        /** @description The move to play, in UCI format */
        move: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The move was successfully made. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The move failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  boardGameChatGet: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The messages posted in the chat. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["GameChat"];
        };
      };
    };
  };
  boardGameChatPost: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @enum {string} */
          room: "player" | "spectator";
          /** @example Thank you for the game! */
          text: string;
        };
      };
    };
    responses: {
      /** @description The message was successfully posted in the chat. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The posting of the message in the chat failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  boardGameAbort: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The game successfully aborted. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The abortion of the game failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  boardGameResign: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The game was successfully resigned. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The resigning from the game failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  boardGameDraw: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
        accept: boolean | "yes";
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The draw offer was successfully sent. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The draw offering failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  boardGameTakeback: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
        accept: boolean | "yes";
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The takeback offer was successfully sent. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The takeback offering failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  boardGameClaimVictory: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The victory was successfully claimed. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The victory claim has failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  boardGameBerserk: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The player successfully went berserk. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The berserk has failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  apiBotOnline: {
    parameters: {
      query?: {
        /** @description How many bot users to fetch */
        nb?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of online bot users */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["User"];
        };
      };
    };
  };
  botAccountUpgrade: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The bot account was successfully upgraded. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The upgrade of the bot account failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  botGameStream: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The stream of the bot game. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson":
            | components["schemas"]["GameFullEvent"]
            | components["schemas"]["GameStateEvent"]
            | components["schemas"]["ChatLineEvent"]
            | components["schemas"]["OpponentGone"];
        };
      };
      /** @description The bot game was not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["NotFound"];
        };
      };
    };
  };
  botGameMove: {
    parameters: {
      query?: {
        /** @description Whether to offer (or agree to) a draw */
        offeringDraw?: boolean;
      };
      header?: never;
      path: {
        gameId: string;
        /** @description The move to play, in UCI format */
        move: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The bot move was successfully made. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The bot move failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  botGameChatGet: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The messages posted in the chat. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["GameChat"];
        };
      };
    };
  };
  botGameChat: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @enum {string} */
          room: "player" | "spectator";
          /** @example Thank you for the game! */
          text: string;
        };
      };
    };
    responses: {
      /** @description The message was successfully posted in chat. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The posting of the  message in chat failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  botGameAbort: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The game was successfully aborted. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The abortion of the game failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  botGameResign: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The game was successfully resigned from. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description Resigning the game failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  botGameDraw: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
        accept: boolean | "yes";
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The draw offer was successfully sent. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The draw offering failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  botGameTakeback: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
        accept: boolean | "yes";
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The takeback offer was successfully sent. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The takeback offering failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  botGameClaimVictory: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The victory was successfully claimed. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The victory claim has failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  challengeList: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of challenges created by or targeted at the logged in user. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** @description Incoming challenges i.e. targeted at you */
            in?: components["schemas"]["ChallengeJson"][];
            /** @description Outgoing challenges i.e. created by you */
            out?: components["schemas"]["ChallengeJson"][];
          };
        };
      };
    };
  };
  challengeCreate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        username: string;
      };
      cookie?: never;
    };
    /** @description Parameters of the challenge */
    requestBody?: {
      content: {
        "application/x-www-form-urlencoded": {
          /**
           * @description Game is rated and impacts players ratings
           * @default false
           */
          rated?: boolean;
          /**
           * @description Clock initial time in seconds. If empty, a correspondence game is created. Valid values are 0, 15, 30, 45, 60, 90, and any multiple of 60 up to 10800 (3 hours).
           * @example 300
           */
          "clock.limit"?: number;
          /**
           * @description Clock increment in seconds. If empty, a correspondence game is created.
           * @example 1
           */
          "clock.increment"?: number;
          /**
           * @description Days per move, for correspondence games. Clock settings must be omitted.
           * @enum {integer}
           */
          days?: 1 | 2 | 3 | 5 | 7 | 10 | 14;
          /**
           * @description Which color you get to play
           * @default random
           * @enum {string}
           */
          color?: "random" | "white" | "black";
          variant?: components["schemas"]["VariantKey"];
          fen?: components["schemas"]["FromPositionFEN"];
          /** @description If set, the response is streamed as [ndjson](#section/Introduction/Streaming-with-ND-JSON).
           *     The challenge is kept alive until the connection is closed by the client.
           *     When the challenge is accepted, declined or canceled, a message of the form `{"done":"accepted"}` is sent,
           *     then the connection is closed by the server.
           *     If not set, the response is not streamed, and the challenge expires after 20s if not accepted.
           *      */
          keepAliveStream?: boolean;
          /**
           * @description Extra game rules separated by commas.
           *     Example: `noAbort,noRematch`
           *
           * @enum {string}
           */
          rules?:
            | "noAbort"
            | "noRematch"
            | "noGiveTime"
            | "noClaimWin"
            | "noEarlyDraw";
        };
      };
    };
    responses: {
      /** @description The challenge was successfully created. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ChallengeJson"];
        };
      };
      /** @description The creation of the challenge failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  challengeShow: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The challenge ID */
        challengeId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The challenge for that ID. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ChallengeJson"];
        };
      };
    };
  };
  challengeAccept: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        challengeId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The challenge was successfully accepted. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The challenge to accept was not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["NotFound"];
        };
      };
    };
  };
  challengeDecline: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        challengeId: string;
      };
      cookie?: never;
    };
    /** @description Details related to decline of challenge */
    requestBody?: {
      content: {
        "application/x-www-form-urlencoded": {
          /**
           * @description Reason challenge was declined. It will be translated to the player's language. See [the full list in the translation file](https://github.com/ornicar/lila/blob/master/translation/source/challenge.xml#L14).
           * @enum {string}
           */
          reason?:
            | "generic"
            | "later"
            | "tooFast"
            | "tooSlow"
            | "timeControl"
            | "rated"
            | "casual"
            | "standard"
            | "variant"
            | "noBot"
            | "onlyBot";
        };
      };
    };
    responses: {
      /** @description The challenge was successfully declined. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The challenge to decline was not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["NotFound"];
        };
      };
    };
  };
  challengeCancel: {
    parameters: {
      query?: {
        /** @description Optional `challenge:write` token of the opponent. If set, the game can be canceled even if both players have moved. */
        opponentToken?: string;
      };
      header?: never;
      path: {
        challengeId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The challenge was successfully cancelled. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The challenge to cancel was not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["NotFound"];
        };
      };
    };
  };
  challengeAi: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters of the game */
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description AI strength */
          level?: number;
          /**
           * @description Clock initial time in seconds. If empty, a correspondence game is created.
           * @example 300
           */
          "clock.limit"?: number;
          /**
           * @description Clock increment in seconds. If empty, a correspondence game is created.
           * @example 1
           */
          "clock.increment"?: number;
          /**
           * @description Days per move, for correspondence games. Clock settings must be omitted.
           * @enum {integer}
           */
          days?: 1 | 2 | 3 | 5 | 7 | 10 | 14;
          /**
           * @description Which color you get to play
           * @default random
           * @enum {string}
           */
          color?: "random" | "white" | "black";
          variant?: components["schemas"]["VariantKey"];
          fen?: components["schemas"]["FromPositionFEN"];
        };
      };
    };
    responses: {
      /** @description The game with Lichess AI was successfully started. */
      201: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["GameJson"];
        };
      };
      /** @description The creation of a game with Lichess AI failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  challengeOpen: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters of the game */
    requestBody?: {
      content: {
        "application/x-www-form-urlencoded": {
          /**
           * @description Game is rated and impacts players ratings
           * @default false
           */
          rated?: boolean;
          /**
           * @description Clock initial time in seconds. If empty, a correspondence game is created.
           * @example 300
           */
          "clock.limit"?: number;
          /**
           * @description Clock increment in seconds. If empty, a correspondence game is created.
           * @example 1
           */
          "clock.increment"?: number;
          /**
           * @description Days per turn. For correspondence challenges.
           * @enum {integer}
           */
          days?: 1 | 2 | 3 | 5 | 7 | 10 | 14;
          variant?: components["schemas"]["VariantKey"];
          fen?: components["schemas"]["FromPositionFEN"];
          /** @description Optional name for the challenge, that players will see on the challenge page. */
          name?: string;
          /**
           * @description Extra game rules separated by commas.
           *     Example: `noRematch,noGiveTime`
           *     The `noAbort` rule is available for Lichess admins only
           *
           * @enum {string}
           */
          rules?:
            | "noRematch"
            | "noGiveTime"
            | "noClaimWin"
            | "noEarlyDraw"
            | "noAbort";
          /** @description Optional pair of usernames, separated by a comma.
           *     If set, only these users will be allowed to join the game.
           *     The first username gets the white pieces.
           *     Example: `Username1,Username2`
           *      */
          users?: string;
          /**
           * Format: int64
           * @description Timestamp in milliseconds to expire the challenge. Defaults to 24h after creation. Can't be more than 2 weeks after creation.
           */
          expiresAt?: number;
        };
      };
    };
    responses: {
      /** @description The challenge was successfully created. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ChallengeOpenJson"];
        };
      };
      /** @description The creation of the challenge failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  challengeStartClocks: {
    parameters: {
      query: {
        /** @description OAuth token of a player */
        token1: string;
        /** @description OAuth token of the other player. Omit for AI games that have only one player. */
        token2?: string;
      };
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The clock of a game was successfully started. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  bulkPairingList: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The list of bulk pairing the logged in user created. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BulkPairing"][];
        };
      };
    };
  };
  bulkPairingCreate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters of the pairings */
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description OAuth tokens of all the players to pair, with the syntax `tokenOfWhitePlayerInGame1:tokenOfBlackPlayerInGame1,tokenOfWhitePlayerInGame2:tokenOfBlackPlayerInGame2,...`.
           *     The 2 tokens of the players of a game are separated with `:`. The first token gets the white pieces. Games are separated with `,`.
           *     Up to 1000 tokens can be sent, for a max of 500 games.
           *     Each token must be included at most once.
           *     Example: `token1:token2,token3:token4,token5:token6`
           *      */
          players?: string;
          /** @description Clock initial time in seconds. Example: `600`
           *      */
          "clock.limit"?: number;
          /** @description Clock increment in seconds. Example: `2`
           *      */
          "clock.increment"?: number;
          /**
           * @description Days per turn. For correspondence games only.
           * @enum {integer}
           */
          days?: 1 | 2 | 3 | 5 | 7 | 10 | 14;
          /**
           * Format: int64
           * @description Date at which the games will be created as a Unix timestamp in milliseconds.
           *     Up to 7 days in the future.
           *     Omit, or set to current date and time, to start the games immediately.
           *     Example: `1612289869919`
           *
           */
          pairAt?: number;
          /**
           * Format: int64
           * @description Date at which the clocks will be automatically started as a Unix timestamp in milliseconds.
           *     Up to 7 days in the future.
           *     Note that the clocks can start earlier than specified, if players start making moves in the game.
           *     If omitted, the clocks will not start automatically.
           *     Example: `1612289869919`
           *
           */
          startClocksAt?: number;
          /**
           * @description Game is rated and impacts players ratings
           * @default false
           */
          rated?: boolean;
          variant?: components["schemas"]["VariantKey"];
          fen?: components["schemas"]["FromPositionFEN"];
          /**
           * @description Message that will be sent to each player, when the game is created.  It is sent from your user account.
           *     `{opponent}` and `{game}` are placeholders that will be replaced with the opponent and the game URLs.
           *     You can omit this field to send the default message,
           *     but if you set your own message, it must at least contain the `{game}` placeholder.
           *
           * @default Your game with {opponent} is ready: {game}.
           */
          message?: string;
          /**
           * @description Extra game rules separated by commas.
           *     Example: `noAbort,noRematch`
           *
           * @enum {string}
           */
          rules?:
            | "noAbort"
            | "noRematch"
            | "noGiveTime"
            | "noClaimWin"
            | "noEarlyDraw";
        };
      };
    };
    responses: {
      /** @description The bulk pairing has been successfully created. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BulkPairing"];
        };
      };
      /** @description The creation of the bulk pairings failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  bulkPairingStartClocks: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The clocks of the games of a bulk pairing were successfully started. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The bulk pairing was not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["NotFound"];
        };
      };
    };
  };
  bulkPairingGet: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The bulk pairing. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["BulkPairing"];
        };
      };
      /** @description The bulk pairing was not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["NotFound"];
        };
      };
    };
  };
  bulkPairingDelete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The bulk pairing was successfully deleted. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The bulk pairing to delete was not found. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["NotFound"];
        };
      };
    };
  };
  bulkPairingIdGamesGet: {
    parameters: {
      query?: {
        /** @description Include the PGN moves. */
        moves?: boolean;
        /** @description Include the full PGN within the JSON response, in a `pgn` field. */
        pgnInJson?: boolean;
        /** @description Include the PGN tags. */
        tags?: boolean;
        /** @description Include clock status when available.
         *     Either as PGN comments: `2. exd5 { [%clk 1:01:27] } e5 { [%clk 1:01:28] }`
         *     Or in a `clocks` JSON field, as centisecond integers, depending on the response type.
         *      */
        clocks?: boolean;
        /** @description Include analysis evaluations and comments, when available.
         *     Either as PGN comments: `12. Bxf6 { [%eval 0.23] } a3 { [%eval -1.09] }`
         *     Or in an `analysis` JSON field, depending on the response type.
         *      */
        evals?: boolean;
        /** @description Include [accuracy percent](https://lichess.org/page/accuracy) of each player, when available. Only available in JSON.
         *      */
        accuracy?: boolean;
        /** @description Include the opening name.
         *     Example: `[Opening "King's Gambit Accepted, King's Knight Gambit"]`
         *      */
        opening?: boolean;
        /** @description Plies which mark the beginning of the middlegame and endgame.
         *     Only available in JSON
         *      */
        division?: boolean;
        /** @description Insert textual annotations in the PGN about the opening, analysis variations, mistakes, and game termination.
         *     Example: `5... g4? { (-0.98  0.60) Mistake. Best move was h6. } (5... h6 6. d4 Ne7 7. g3 d5 8. exd5 fxg3 9. hxg3 c6 10. dxc6)`
         *      */
        literate?: boolean;
      };
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The representation of the games. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["GamePgn"];
          "application/x-ndjson": components["schemas"]["GameJson"];
        };
      };
    };
  };
  roundAddTime: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
        /** @description How many seconds to give */
        seconds: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Time was successfully added to the opponent's clock. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  adminChallengeTokens: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /**
           * @description Usernames separated with commas
           * @example thibault,neio,lizen2,lizen3
           */
          users: string;
          /**
           * @description User visible description of the token
           * @example FIDE tournament XYZ
           */
          description: string;
        };
      };
    };
    responses: {
      /** @description The `challenge:write` tokens of each user */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            [key: string]: string;
          };
        };
      };
      /** @description The creation of the tokens failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  inboxUsername: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        username: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @example Thank you for the game! */
          text: string;
        };
      };
    };
    responses: {
      /** @description The private message has been successfully sent. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
      /** @description The sending of the private message has failed. */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  apiCloudEval: {
    parameters: {
      query: {
        /**
         * @description FEN of the position
         * @example r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 3 3
         */
        fen: string;
        /** @description Number of variations */
        multiPv?: number;
        /** @description Variant */
        variant?: components["schemas"]["VariantKey"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The evaluation of the position. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["CloudEval"];
        };
      };
      /** @description The position was not found in the cloud evaluation database. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** @example No cloud evaluation available for that position */
            error?: string;
          };
        };
      };
    };
  };
  apiExternalEngineList: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A list of external engines. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ExternalEngine"][];
        };
      };
    };
  };
  apiExternalEngineCreate: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description A new external engine registration. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExternalEngineRegistration"];
      };
    };
    responses: {
      /** @description The registered engine. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ExternalEngine"];
        };
      };
    };
  };
  apiExternalEngineGet: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The external engine id.
         * @example eei_aTKImBJOnv6j
         */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A registered engine. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ExternalEngine"];
        };
      };
    };
  };
  apiExternalEnginePut: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The external engine id.
         * @example eei_aTKImBJOnv6j
         */
        id: string;
      };
      cookie?: never;
    };
    /** @description A modified engine registration. */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ExternalEngineRegistration"];
      };
    };
    responses: {
      /** @description A registered engine. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["ExternalEngine"];
        };
      };
    };
  };
  apiExternalEngineDelete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The external engine id.
         * @example eei_aTKImBJOnv6j
         */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Engine successfully deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["Ok"];
        };
      };
    };
  };
  apiExternalEngineAnalyse: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The external engine id.
         * @example eei_aTKImBJOnv6j
         */
        id: string;
      };
      cookie?: never;
    };
    /** @description Engine credentials and analysis request. */
    requestBody: {
      content: {
        "application/json": {
          /** @example ees_mdF2hK0hlKGSPeC6 */
          clientSecret: string;
          work: components["schemas"]["ExternalEngineWork"];
        };
      };
    };
    responses: {
      /** @description Stream of analysis output */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": {
            /**
             * @description Number of milliseconds the search has been going on
             * @example 6880
             */
            time: number;
            /**
             * @description Current search depth
             * @example 25
             */
            depth: number;
            /**
             * @description Number of nodes visited so far
             * @example 7230340
             */
            nodes: number;
            /** @description Information about up to 5 pvs, with the primary pv at index 0. */
            pvs: {
              /**
               * @description Current search depth of the pv
               * @example 25
               */
              depth: number;
              /**
               * @description Evaluation in centi-pawns, from White's point of view
               * @example 40
               */
              cp?: number;
              /** @description Evaluation in signed moves to mate, from White's point of view */
              mate?: number;
              /**
               * @description Variation in UCI notation
               * @example [
               *       "e2e4",
               *       "c7c6",
               *       "g1f3",
               *       "d7d5",
               *       "d2d3",
               *       "d5e4"
               *     ]
               */
              moves: string[];
            }[];
          };
        };
      };
    };
  };
  apiExternalEngineAcquire: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Provider credentials. */
    requestBody: {
      content: {
        "application/json": {
          /** @example Dee3uwieZei9ahpaici9bee2yahsai0K */
          providerSecret?: string;
        };
      };
    };
    responses: {
      /** @description Analysis has been requested */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** @example aingoohiJee2sius */
            id: string;
            work: components["schemas"]["ExternalEngineWork"];
            engine: components["schemas"]["ExternalEngine"];
          };
        };
      };
      /** @description No pending analysis */
      204: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  apiExternalEngineSubmit: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    /** @description Analysis results */
    requestBody: {
      content: {
        /** @example info multipv 1 depth 20 seldepth 30 time 1373 nodes 1494341 score cp 47 hashfull 594 nps 1088376 tbhits 0 pv d2d4 d7d5 c2c4 e7e6 b1c3 f8b4 c4d5 e6d5 g1f3 g8f6 c1g5 h7h6 g5f6 d8f6 d1b3 c7c5 e2e3 b8c6 d4c5 e8g8 f1d3 */
        "text/plain": string;
      };
    };
    responses: {
      /** @description Thanks */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  oauth: {
    parameters: {
      query: {
        /** @description Must be `code`. */
        response_type: string;
        /**
         * @description Arbitrary identifier that uniquely identifies your application.
         * @example example.com
         */
        client_id: string;
        /** @description The absolute URL that the user should be redirected to with the authorization result. */
        redirect_uri: string;
        /** @description Must be `S256`. */
        code_challenge_method: string;
        /** @description Compute `BASE64URL(SHA256(code_verifier))`. */
        code_challenge: string;
        /** @description Space separated list of requested OAuth scopes, if any. */
        scope?: string;
        /** @description Hint that you want the user to log in with a specific Lichess username. */
        username?: string;
        /** @description Arbitrary state that will be returned verbatim with the authorization result. */
        state?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Authorization prompt will be displayed to the user. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  apiToken: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /**
           * @description Must be `authorization_code`.
           * @example authorization_code
           */
          grant_type?: string;
          /**
           * @description The authorization code that was sent in the `code` parameter to your `redirect_uri`.
           * @example liu_iS1uOZg99Htmo58ex2jKgYziUfzsnAl0
           */
          code?: string;
          /**
           * @description A `code_challenge` was used to request the authorization code. This must be the `code_verifier` it was derived from.
           * @example Ry1rbGdOMTQtUjhOc0lmTnFKak1LTHV0NjlRMll2aXYtTThkQnlJRkRpaGwyQjh0ZDNFdzFPSG9KUlY4M1NrRzJ5ZHhUdjVZR08zLTZOT3dCN2xLfjZOXzU2WHk4SENP
           */
          code_verifier?: string;
          /**
           * @description Must match the `redirect_uri` used to request the authorization code.
           * @example http://example.com/
           */
          redirect_uri?: string;
          /**
           * @description Must match the `client_id` used to request the authorization code.
           * @example example.com
           */
          client_id?: string;
        };
      };
    };
    responses: {
      /** @description Access token successfully obtained. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** @example Bearer */
            token_type: string;
            /** @example lio_pLwAbN7lFPklzY2m8lTOI1DGApS84u57 */
            access_token: string;
            /** @example 31536000 */
            expires_in: number;
          };
        };
      };
      /** @description Failed to obtain access token. */
      400: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["OAuthError"];
        };
      };
    };
  };
  apiTokenDelete: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Access token revoked. */
      204: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  tokenTest: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description OAuth tokens separated by commas. Up to 1000. */
    requestBody: {
      content: {
        /** @example lip_AvsS88TozFeSMEaoLN5c,lip_badToken */
        "text/plain": string;
      };
    };
    responses: {
      /** @description The representation of the OAuth tokens. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            [key: string]: {
              userId?: string;
              /** @description Comma-separated list of scopes. Empty string if the token has no scopes. */
              scopes?: string;
              /** @description Unix-timestampe in milliseconds or null if the token never expires. */
              expires?: number | null;
            } | null;
          };
        };
      };
    };
  };
  openingExplorerMaster: {
    parameters: {
      query?: {
        /**
         * @description FEN of the root position
         * @example rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
         */
        fen?: string;
        /**
         * @description Comma separated sequence of legal moves in UCI notation.
         *     Play additional moves starting from `fen`.
         *     Required to find an opening name, if `fen` is not an exact match
         *     for a named position.
         *
         * @example d2d4,d7d5,c2c4,c7c6,c4d5
         */
        play?: string;
        /** @description Include only games from this year or later */
        since?: number;
        /** @description Include only games from this year or earlier */
        until?: number;
        /** @description Number of most common moves to display */
        moves?: number;
        /** @description Number of top games to display */
        topGames?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Opening statistics and game references for the position. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["OpeningExplorerMasters"];
        };
      };
    };
  };
  openingExplorerLichess: {
    parameters: {
      query?: {
        /** @description Variant */
        variant?: components["schemas"]["VariantKey"];
        /**
         * @description FEN or EPD of the root position
         * @example rnbqkbnr/ppp1pppp/8/3pP3/8/8/PPPP1PPP/RNBQKBNR b KQkq - 0 2
         */
        fen?: string;
        /**
         * @description Comma separated sequence of legal moves in UCI notation.
         *     Play additional moves starting from `fen`.
         *     Required to find an opening name, if `fen` is not an exact match
         *     for a named position.
         *
         * @example d2d4,d7d5,c2c4,c7c6,c4d5
         */
        play?: string;
        /** @description Comma separated list of game speeds to filter by */
        speeds?: components["schemas"]["Speed"][];
        /** @description Comma separated list of ratings groups to filter by.
         *     Each group ranges from its value to the next higher
         *     group in the enum (`0` from 0 to 999, `1000` from 1000 to 1199,
         *     ..., `2500` from 2500 to any rating above).
         *      */
        ratings?: (0 | 1000 | 1200 | 1400 | 1600 | 1800 | 2000 | 2200 | 2500)[];
        /** @description Include only games from this month or later */
        since?: string;
        /** @description Include only games from this month or earlier */
        until?: string;
        /** @description Number of most common moves to display */
        moves?: number;
        /** @description Number of top games to display */
        topGames?: number;
        /** @description Number of recent games to display */
        recentGames?: number;
        /** @description Optionally retrieve history */
        history?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Opening statistics and game references for the position. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["OpeningExplorerLichess"];
        };
      };
    };
  };
  openingExplorerPlayer: {
    parameters: {
      query: {
        /**
         * @description Username or ID of the player
         * @example revoof
         */
        player: string;
        /**
         * @description Look for games with *player* on the given side
         * @example white
         */
        color: "white" | "black";
        /** @description Variant */
        variant?: components["schemas"]["VariantKey"];
        /**
         * @description FEN of the root position
         * @example rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
         */
        fen?: string;
        /**
         * @description Comma separated sequence of legal moves in UCI notation.
         *     Play additional moves starting from `fen`.
         *     Required to find an opening name, if `fen` is not an exact match
         *     for a named position.
         *
         * @example d2d4,d7d5
         */
        play?: string;
        /** @description Comma separated list of game speeds to look for */
        speeds?: components["schemas"]["Speed"][];
        /** @description Comma separated list of modes */
        modes?: ("casual" | "rated")[];
        /** @description Include only games from this month or later */
        since?: string;
        /** @description Include only games from this month or earlier */
        until?: string;
        /** @description Number of most common moves to display */
        moves?: number;
        /** @description Number of recent games to display */
        recentGames?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Opening statistics and game references for the position. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-ndjson": components["schemas"]["OpeningExplorerPlayer"];
        };
      };
    };
  };
  openingExplorerMasterGame: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        gameId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The PGN representation of the game. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/x-chess-pgn": components["schemas"]["MasterGamePgn"];
        };
      };
    };
  };
  tablebaseStandard: {
    parameters: {
      query: {
        /** @description FEN of the position. Underscores allowed. */
        fen: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The tablebase information for the position in standard chess. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "application/json": components["schemas"]["TablebaseJson"];
        };
      };
    };
  };
  tablebaseAtomic: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The tablebase information for the position in atomic chess. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "text/plain": string;
        };
      };
    };
  };
  antichessAtomic: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The tablebase information for the position in antichess. */
      200: {
        headers: {
          "Access-Control-Allow-Origin"?: string;
          [name: string]: unknown;
        };
        content: {
          "text/plain": string;
        };
      };
    };
  };
}
